{
  "modelLibrary": {
    "name": "BEAST2 Core Library",
    "version": "1.0.0",
    "engine": "BEAST2",
    "engineVersion": "2.7.7",
    "description": "Core model components for BEAST2",
    "types": [
      {
        "name": "String",
        "package": "primitive",
        "description": "Text values",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "String"
        ]
      },
      {
        "name": "Integer",
        "package": "primitive",
        "description": "Integer numbers",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Integer"
        ]
      },
      {
        "name": "Double",
        "package": "primitive",
        "description": "Floating point numbers",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double"
        ]
      },
      {
        "name": "Boolean",
        "package": "primitive",
        "description": "True\/false values",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Boolean"
        ]
      },
      {
        "name": "BEASTInterface",
        "package": "beast.base.core",
        "fullyQualifiedName": "beast.base.core.BEASTInterface",
        "description": "BEAST2 BEASTInterface",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "BEASTObject",
        "package": "beast.base.core",
        "fullyQualifiedName": "beast.base.core.BEASTObject",
        "description": "Base class for all BEAST objects, which is pretty much every class you want to incorporate in a model.",
        "isAbstract": true,
        "isInterface": false,
        "implements": [
          "BEASTInterface"
        ]
      },
      {
        "name": "Distribution",
        "package": "beast.base.inference",
        "fullyQualifiedName": "beast.base.inference.Distribution",
        "description": "Probabilistic representation that can produce a log probability for instance for running an MCMC chain.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "ParametricDistribution",
        "package": "beast.base.inference.distribution",
        "fullyQualifiedName": "beast.base.inference.distribution.ParametricDistribution",
        "description": "A class that describes a parametric distribution, that is, a distribution that takes some parameters\/valuables as inputs and can produce (cumulative) densities and inverse cumulative densities.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "StateNode",
        "package": "beast.base.inference",
        "fullyQualifiedName": "beast.base.inference.StateNode",
        "description": "A node that can be part of the state.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "CalculationNode",
        "package": "beast.base.inference",
        "fullyQualifiedName": "beast.base.inference.CalculationNode",
        "description": "BEASTObject that performs calculations based on the State.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "StateNodeInitialiser",
        "package": "beast.base.inference",
        "fullyQualifiedName": "beast.base.inference.StateNodeInitialiser",
        "description": "BEAST2 StateNodeInitialiser",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "GeneralParameterList",
        "package": "beast.base.inference.parameter",
        "fullyQualifiedName": "beast.base.inference.parameter.GeneralParameterList",
        "description": "State node representing a list of parameter objects, used for model selection problems. The parameters involved are not instances of Parameter.Base, but are instead instances of a local class QuietParameter which is not itself a StateNode.  All constituent parameters must have identical dimensions and bounds.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "StateNode"
      },
      {
        "name": "Map",
        "package": "beast.base.inference.parameter",
        "fullyQualifiedName": "beast.base.inference.parameter.Map",
        "description": "Unordered set mapping keys to values",
        "isAbstract": true,
        "isInterface": false,
        "extends": "StateNode"
      },
      {
        "name": "TreeDistribution",
        "package": "beast.base.evolution.tree",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeDistribution",
        "description": "Distribution on a tree, typically a prior such as Coalescent or Yule",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "SpeciesTreeDistribution",
        "package": "beast.base.evolution.speciation",
        "fullyQualifiedName": "beast.base.evolution.speciation.SpeciesTreeDistribution",
        "description": "A likelihood function for speciation processes.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "TreeDistribution"
      },
      {
        "name": "BranchRateModel.Base",
        "package": "beast.base.evolution.branchratemodel",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.BranchRateModel$Base",
        "description": "Base implementation of a clock model.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "BranchRateModel"
        ]
      },
      {
        "name": "SubstitutionModel.Base",
        "package": "beast.base.evolution.substitutionmodel",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.SubstitutionModel$Base",
        "description": "Base implementation of a substitution model.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "SubstitutionModel"
        ]
      },
      {
        "name": "SubstitutionModel.NucleotideBase",
        "package": "beast.base.evolution.substitutionmodel",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.SubstitutionModel$NucleotideBase",
        "description": "Base implementation of a nucleotide substitution model.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "SubstitutionModel.Base"
      },
      {
        "name": "EmpiricalSubstitutionModel",
        "package": "beast.base.evolution.substitutionmodel",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.EmpiricalSubstitutionModel",
        "description": "A substitution model where the rates and frequencies are obtained from empirical evidence. Especially, amino acid models like WAG.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "PopulationFunction.Abstract",
        "package": "beast.base.evolution.tree.coalescent",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.PopulationFunction$Abstract",
        "description": "An implementation of a population size function beastObject.Also note that if you are dealing with a diploid population N0 will be the number of alleles, not the number of individuals.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "PopulationFunction"
        ]
      },
      {
        "name": "DataType.Base",
        "package": "beast.base.evolution.datatype",
        "fullyQualifiedName": "beast.base.evolution.datatype.DataType$Base",
        "description": "Basic data type implementation, with methods for decoding and encoding sequence strings",
        "isAbstract": true,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "UltrametricSpeciationModel",
        "package": "beastlabs.evolution.speciation",
        "fullyQualifiedName": "beastlabs.evolution.speciation.UltrametricSpeciationModel",
        "description": "Experimental code with unknown use. If you know, fill this in.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "SpeciesTreeDistribution"
      },
      {
        "name": "SABDParameterization",
        "package": "sa.evolution.speciation",
        "fullyQualifiedName": "sa.evolution.speciation.SABDParameterization",
        "description": "BEAST2 SABDParameterization",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "LoggableFunction",
        "package": "feast.function",
        "fullyQualifiedName": "feast.function.LoggableFunction",
        "description": "BEAST2 LoggableFunction",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "LogFileState",
        "package": "feast.fileio.logfileiterator",
        "fullyQualifiedName": "feast.fileio.logfileiterator.LogFileState",
        "description": "A container for one or more state variables to be populated on the basis of an input log file.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "Function",
        "package": "beast.base.core",
        "fullyQualifiedName": "beast.base.core.Function",
        "description": "BEAST2 Function",
        "isAbstract": true,
        "isInterface": true,
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Integer"
        ]
      },
      {
        "name": "SiteModelInterface",
        "package": "beast.base.evolution.sitemodel",
        "fullyQualifiedName": "beast.base.evolution.sitemodel.SiteModelInterface",
        "description": "BEAST2 SiteModelInterface",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "Parameter",
        "package": "beast.base.inference.parameter",
        "fullyQualifiedName": "beast.base.inference.parameter.Parameter",
        "description": "BEAST2 Parameter",
        "isAbstract": true,
        "isInterface": true,
        "primitiveAssignable": true
      },
      {
        "name": "BranchRateModelSB3",
        "package": "starbeast3.evolution.branchratemodel",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.BranchRateModelSB3",
        "description": "BEAST2 BranchRateModelSB3",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "TreeInterface",
        "package": "beast.base.evolution.tree",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeInterface",
        "description": "BEAST2 TreeInterface",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "BranchRateModel",
        "package": "beast.base.evolution.branchratemodel",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.BranchRateModel",
        "description": "Defines a mean rate for each branch in the beast.tree.",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "SubstitutionModel",
        "package": "beast.base.evolution.substitutionmodel",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.SubstitutionModel",
        "description": "Specifies substitution model from which a transition probability matrix for a given distance can be obtained.",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "PopulationFunction",
        "package": "beast.base.evolution.tree.coalescent",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.PopulationFunction",
        "description": "BEAST2 PopulationFunction",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "PopulationModel",
        "package": "starbeast3.evolution.speciation",
        "fullyQualifiedName": "starbeast3.evolution.speciation.PopulationModel",
        "description": "BEAST2 PopulationModel",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "Distance",
        "package": "beast.base.evolution.distance",
        "fullyQualifiedName": "beast.base.evolution.distance.Distance",
        "description": "Provides distance between taxa",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "TreeMetric",
        "package": "beast.base.evolution.tree",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeMetric",
        "description": "BEAST2 TreeMetric",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "Transform",
        "package": "beast.base.inference.operator.kernel",
        "fullyQualifiedName": "beast.base.inference.operator.kernel.Transform",
        "description": "BEAST2 Transform",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "Transform",
        "package": "beastlabs.util",
        "fullyQualifiedName": "beastlabs.util.Transform",
        "description": "BEAST2 Transform",
        "isAbstract": true,
        "isInterface": true
      },
      {
        "name": "SiteModelInterface.Base",
        "package": "beast.base.evolution.sitemodel",
        "fullyQualifiedName": "beast.base.evolution.sitemodel.SiteModelInterface$Base",
        "description": "Base implementation of a site model with substitution model and rate categories.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "SiteModelInterface"
        ]
      },
      {
        "name": "Parameter.Base",
        "package": "beast.base.inference.parameter",
        "fullyQualifiedName": "beast.base.inference.parameter.Parameter$Base",
        "description": "A parameter represents a value in the state space that can be changed by operators.",
        "isAbstract": true,
        "isInterface": false,
        "extends": "StateNode",
        "implements": [
          "Parameter"
        ],
        "primitiveAssignable": true
      },
      {
        "name": "Transform.MultivariableTransform",
        "package": "beastlabs.util",
        "fullyQualifiedName": "beastlabs.util.Transform$MultivariableTransform",
        "description": "Transforms multiple parameters or trees",
        "isAbstract": true,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "Transform"
        ]
      },
      {
        "name": "Transform.MultivariateTransform",
        "package": "beastlabs.util",
        "fullyQualifiedName": "beastlabs.util.Transform$MultivariateTransform",
        "description": "Transforms multiple parameters or trees",
        "isAbstract": true,
        "isInterface": false,
        "extends": "Transform.MultivariableTransform"
      },
      {
        "name": "Transform.MultivariableTransformWithParameter",
        "package": "beastlabs.util",
        "fullyQualifiedName": "beastlabs.util.Transform$MultivariableTransformWithParameter",
        "description": "Transforms multiple parameters or trees",
        "isAbstract": true,
        "isInterface": false,
        "extends": "Transform.MultivariableTransform"
      },
      {
        "name": "Transform.UnivariableTransform",
        "package": "beastlabs.util",
        "fullyQualifiedName": "beastlabs.util.Transform$UnivariableTransform",
        "description": "Transforms parameter of dimension 1",
        "isAbstract": true,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "Transform"
        ]
      },
      {
        "name": "SpeciesTreePrior.TreePopSizeFunction",
        "package": "starbeast3.evolution.speciation",
        "fullyQualifiedName": "starbeast3.evolution.speciation.SpeciesTreePrior$TreePopSizeFunction",
        "description": "Enum type for SpeciesTreePrior",
        "isEnum": true,
        "values": [
          "constant",
          "linear",
          "linear_with_constant_root"
        ]
      },
      {
        "name": "ExpCalculator",
        "package": "feast",
        "fullyQualifiedName": "feast.expressions.ExpCalculator",
        "description": "Evaluates simple expressions of parameters involving parameters, including parameters of different lengths.  Individual elements of parameters can be specified using [] notation.  Parameters with differing dimension are combined as in R, with the shortest  parameter being repeated as many times as necessary.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "ExpCalculatorDistribution",
        "package": "feast",
        "fullyQualifiedName": "feast.expressions.ExpCalculatorDistribution",
        "description": "A distribution composed from an expression string.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "ExpCalculatorParametricDistribution",
        "package": "feast",
        "fullyQualifiedName": "feast.expressions.ExpCalculatorParametricDistribution",
        "description": "Expression calculator distribution for use with the Prior class.  This is a somewhat restricted version of ExpCalculatorDistribution as it does not allow for general multivariate distributions.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "AlignmentFromFasta",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.AlignmentFromFasta",
        "description": "Objects of this type are regular beast Alignments, but are populated using data read in from an external fasta file.  Sequence labels used as taxon labels.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "AlignmentFromFile"
      },
      {
        "name": "AlignmentFromFile",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.AlignmentFromFile",
        "description": "BEAST2 AlignmentFromFile",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Alignment"
      },
      {
        "name": "AlignmentFromNexus",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.AlignmentFromNexus",
        "description": "Objects of this type are regular beast Alignments, but are populated using data read in from an external NEXUS file.  Sequence labels used as taxon labels.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "AlignmentFromFile"
      },
      {
        "name": "DummyPosterior",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.DummyPosterior",
        "description": "BEAST2 DummyPosterior",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "LogFileRealParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.LogFileRealParameter",
        "description": "Represents a RealParameter to be read in from a log file as part of a LogFileIterator run.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "TraceLogFileState",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.TraceLogFileState",
        "description": "A LogFileState representing the mapping from input trace log file samples to BEAST 2 Parameters.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LogFileState"
      },
      {
        "name": "TreeLogFileState",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.TreeLogFileState",
        "description": "A LogFileState representing the mapping from input tree log file samples to BEAST 2 Trees.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LogFileState"
      },
      {
        "name": "RealParameterFromLabelledXSV",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.RealParameterFromLabelledXSV",
        "description": "Initializes a RealParameter with values read from a CSV\/TSV file in row-major order.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "RealParameterFromXSV",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.RealParameterFromXSV",
        "description": "Initializes a RealParameter with values read from a CSV\/TSV file in row-major order.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "TaxonSetFromTree",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TaxonSetFromTree",
        "description": "Represents a TaxonSet object where the taxon names are extracted from the given tree.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TaxonSet"
      },
      {
        "name": "TipDatesFromTree",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TipDatesFromTree",
        "description": "Traitset for tip dates obtained from input tree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TraitSet"
      },
      {
        "name": "TraitSetFromTaxonSet",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TraitSetFromTaxonSet",
        "description": "Initialize a trait set from a taxon set. Permits similar functionality to the 'autoconfigure' option in BEAUti.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TraitSet"
      },
      {
        "name": "TraitSetFromXSV",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TraitSetFromXSV",
        "description": "Initialize a trait set from a CSV\/TSV file.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TraitSet"
      },
      {
        "name": "TreeFromNewickFile",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TreeFromNewickFile",
        "description": "Wrapper around TreeParser to enable reading newick strings from files.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeParser"
      },
      {
        "name": "TreeFromNexusFile",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TreeFromNexusFile",
        "description": "Wrapper around TreeParser to enable reading trees from Nexus files.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeParser"
      },
      {
        "name": "Concatenate",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Concatenate",
        "description": "A Function whose elements are the result of concatenating the elements of the input Functions.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "Interleave",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Interleave",
        "description": "A function produced by interleaving the elements of two or more input functions.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "Reverse",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Reverse",
        "description": "A Function whose elements are the elements of the input Function but in reverse order.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "SampleAges",
        "package": "feast",
        "fullyQualifiedName": "feast.function.SampleAges",
        "description": "Function representing ages of sample nodes of tree.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "Scale",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Scale",
        "description": "A Function whose elements are the elements of an input Function scaled by another input Function.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "Sequence",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Sequence",
        "description": "A Function representing a contiguous sequence of integers, e.g. [2,3,4,5].",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "Slice",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Slice",
        "description": "A Function representing a number of elements of another Function.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "TraitSetAsFunction",
        "package": "feast",
        "fullyQualifiedName": "feast.function.TraitSetAsFunction",
        "description": "All trait sets have at least some (potentially useless) representation as a vector of doubles.  This class just allows you to explicitly treat them as Functions.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "UniqueElementCount",
        "package": "feast",
        "fullyQualifiedName": "feast.function.UniqueElementCount",
        "description": "Function representing the number of unique elements of another function.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "LoggableFunction"
      },
      {
        "name": "DirichletProcessPrior",
        "package": "feast",
        "fullyQualifiedName": "feast.modelselect.DirichletProcessPrior",
        "description": "A distribution representing the probability of the elements of an input function (parameter) under a Dirichlet process prior with a particular base distribution (baseDistr) and scale paraemter (scaleParameter). In order to use this, you'll need to ensure operators preserve the equivalence of identical elements of function.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "ModelSelectionParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.modelselect.ModelSelectionParameter",
        "description": "Class of Functions useful for BSSVS-style model selection\/averaging.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "RandomRealParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.parameter.RandomRealParameter",
        "description": "Randomly innitialise a RealParameter by sampling from a ParametricDistribution.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "implements": [
          "StateNodeInitialiser"
        ],
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "RealParameterFromFunction",
        "package": "feast",
        "fullyQualifiedName": "feast.parameter.RealParameterFromFunction",
        "description": "A RealParameter initialized from a function.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "TimeParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.parameter.TimeParameter",
        "description": "RealParameter with a constructor that sets initial values based on formatted dates converted to ages relative to the most recent sample on the tree.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "primitiveAssignable": true
      },
      {
        "name": "CompoundPopulationModel",
        "package": "feast",
        "fullyQualifiedName": "feast.popmodels.CompoundPopulationModel",
        "description": "Population model constructed by piecewise assembly of other population functions.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "ExpressionPopulationModel",
        "package": "feast",
        "fullyQualifiedName": "feast.popmodels.ExpressionPopulationModel",
        "description": "A population model where the population size function is given by an expression evaluated at runtime.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "ShiftedPopulationModel",
        "package": "feast",
        "fullyQualifiedName": "feast.popmodels.ShiftedPopulationModel",
        "description": "A population model which is time-shifted relative to an input population model.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "ShuffledAlignment",
        "package": "feast",
        "fullyQualifiedName": "feast.simulation.ShuffledAlignment",
        "description": "A sequence alignment which is a randomly shuffled version of the input alignment.  Can be used for performing date randomization tests.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Alignment"
      },
      {
        "name": "SimulatedAlignment",
        "package": "feast",
        "fullyQualifiedName": "feast.simulation.SimulatedAlignment",
        "description": "A more flexible alignment simulator. Doesn't require pre-specification of number of taxa.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Alignment"
      },
      {
        "name": "CachedDistribution",
        "package": "ORC",
        "fullyQualifiedName": "orc.consoperators.CachedDistribution",
        "description": "Caches parametric distribution for inverscumulative methods.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "PiecewiseLinearDistribution",
        "package": "ORC",
        "fullyQualifiedName": "orc.consoperators.PiecewiseLinearDistribution",
        "description": "Approximates parametric distribution by piecewise linear approximation.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "DiversificationTurnoverParameterization",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.DiversificationTurnoverParameterization",
        "description": "BEAST2 DiversificationTurnoverParameterization",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SABDParameterization"
      },
      {
        "name": "DiversificationTurnoverPsiExpectedNParameterization",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.DiversificationTurnoverPsiExpectedNParameterization",
        "description": "BEAST2 DiversificationTurnoverPsiExpectedNParameterization",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SABDParameterization"
      },
      {
        "name": "ParameterizedSABirthDeathModel",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.ParameterizedSABirthDeathModel",
        "description": "Calculate tree density under Birth Death Sampling Through Time Model for Epidemics that is the BDM where an individual is sampled at a time with a constant rate psi and where an individual becomes noninfectious immediately after the samplingwith a constant probability r",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SpeciesTreeDistribution"
      },
      {
        "name": "ProbabilitySA",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.ProbabilitySA",
        "description": "BEAST2 ProbabilitySA",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "RateParameterization",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.RateParameterization",
        "description": "BEAST2 RateParameterization",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SABDParameterization"
      },
      {
        "name": "SABirthDeathModel",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.SABirthDeathModel",
        "description": "Calculate tree density under Birth Death Sampling Through Time Model for Epidemics that is the BDM where an individual is sampled at a time with a constant rate psi and where an individual becomes noninfectious immediately after the samplingwith a constant probability r",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeDistribution"
      },
      {
        "name": "AncestryConstraint",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.AncestryConstraint",
        "description": "Method to force extinct samples to be ancestral to a set of taxa in the tree. This is meant to be used for sensitivity analyses and testing purposes only. ",
        "isAbstract": false,
        "isInterface": false,
        "extends": "MRCAPrior"
      },
      {
        "name": "CladeConstraint",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.CladeConstraint",
        "description": "BEAST2 CladeConstraint",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "SamplingDate",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.SamplingDate",
        "description": "BEAST2 SamplingDate",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "TreeWOffset",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.TreeWOffset",
        "description": "BEAST2 TreeWOffset",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "DegenerateBeta",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.DegenerateBeta",
        "description": "BEAST2 DegenerateBeta",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "DegenerateUniform",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.DegenerateUniform",
        "description": "BEAST2 DegenerateUniform",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "SAMRCAPrior",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.SAMRCAPrior",
        "description": "Behaves the same as a MRCAPrior, but allows BEAUti to know how to add the correct operators for tips sampling",
        "isAbstract": false,
        "isInterface": false,
        "extends": "MRCAPrior"
      },
      {
        "name": "SpecialMRCAPrior",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.SpecialMRCAPrior",
        "description": "BEAST2 SpecialMRCAPrior",
        "isAbstract": false,
        "isInterface": false,
        "extends": "MRCAPrior"
      },
      {
        "name": "ClusterZBSATree",
        "package": "SA",
        "fullyQualifiedName": "sa.util.ClusterZBSATree",
        "description": "Create initial beast.tree by hierarchical clustering, either through one of the classic link methods or by neighbor joining. The following link methods are supported: <br\/>o single link, <br\/>o complete link, <br\/>o UPGMA=average link, <br\/>o mean link, <br\/>o centroid, <br\/>o Ward and <br\/>o adjusted complete link <br\/>o neighborjoining <br\/>o neighborjoining2 - corrects tree for tip data, unlike plain neighborjoining",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "ZeroBranchSATreeParser",
        "package": "SA",
        "fullyQualifiedName": "sa.util.ZeroBranchSATreeParser",
        "description": "Create beast.tree by parsing from a specification of a beast.tree (which is a fake SA tree) in Newick format (includes parsing of any meta data in the Newick string).",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "DataNode",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.DataNode",
        "description": "Represents some piece of data for which a likelihood can be calculated",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "FilteredValuable",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.FilteredValuable",
        "description": "selects values from a parameter, for instance all even indexed entries",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "Likelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.Likelihood",
        "description": "Represents one of more likelihoods which represent the probability of some data (e.g. a sequence alignment), possibly conditioned on one or more DataNodes (e.g. a Tree or set of Parameters). The class checks that Data has not defined more than one likelihood.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CompoundDistribution"
      },
      {
        "name": "CompoundRealParameter",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.parameter.CompoundRealParameter",
        "description": "Parmeter consisting of 2 or more RealParameters but behaving like a single RealParameter",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "NormalisedRealParameter",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.parameter.NormalisedRealParameter",
        "description": "Constant value that acts as immutable RealParameter where values are normalised",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "Posterior",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.Posterior",
        "description": "Posterior, consisting of a prior and a likehood",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "LoggableSum",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.util.LoggableSum",
        "description": "Logs the sum of anything that is Valuable",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "ParameterConstrainer",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.util.ParameterConstrainer",
        "description": "Class to constrain a multi-dimensional parameter to have a certain value (like 0) at a certain time range",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "Slice",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.util.Slice",
        "description": "A Function representing a number of elements of another Function.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "PrunedAlignment",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.alignment.PrunedAlignment",
        "description": "Sub-alignment generated by pruning some taxa and\/or some sites. Can automatically detect taxa with non-informative data (all sites are ambiguous).",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Alignment"
      },
      {
        "name": "PrunedRelaxedClockModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.branchratemodel.PrunedRelaxedClockModel",
        "description": "Tree containing a subset of nodes from another tree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base"
      },
      {
        "name": "ExperimentalTreeLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.likelihood.ExperimentalTreeLikelihood",
        "description": "Calculates the likelihood of sequence data on a beast.tree given a site and substitution model using a variant of the 'peeling algorithm'. For details, seeFelsenstein, Joseph (1981). Evolutionary trees from DNA sequences: a maximum likelihood approach. J Mol Evol 17 (6): 368-376.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "SupertreeLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.likelihood.SupertreeLikelihood",
        "description": "A supertree likelihood for a set of subtrees.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "TraitedTreeLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.likelihood.TraitedTreeLikelihood",
        "description": "Performs peeling algorithm over a tree using a trait as values for tips instead of a sequence",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeLikelihood"
      },
      {
        "name": "RandomLocalYuleModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.speciation.RandomLocalYuleModel",
        "description": "A speciation model of a Yule process whose rate of birth changes at different points in the tree.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "UltrametricSpeciationModel"
      },
      {
        "name": "CladeSubstitutionModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.CladeSubstitutionModel",
        "description": "Substitution model dependent on clades. For each clade a substitution model is specified. For nodes that do not fit in a clade a default substitution model is used.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SubstitutionModel.Base"
      },
      {
        "name": "EpochSubstitutionModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.EpochSubstitutionModel",
        "description": "A substitution model that can change at various threshold dates.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SubstitutionModel.Base"
      },
      {
        "name": "GeneralLazySubstitutionModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.GeneralLazySubstitutionModel",
        "description": "Uses a super-relaxed clock model. Note, this should only be used with strict clock models.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "LazyHKY",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.LazyHKY",
        "description": "Lazy version of HKY85 substitution model of nucleotide evolution.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "HKY"
      },
      {
        "name": "Taxon",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.taxonomy.Taxon",
        "description": "For identifying a single taxon, modified to be comparable",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Taxon"
      },
      {
        "name": "CauchyPlusConstant",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.coalescent.CauchyPlusConstant",
        "description": "Population model of the form A\/(B*(t-t0)^2 + 1) + C.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "ExponentialGrowthPlusConstant",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.coalescent.ExponentialGrowthPlusConstant",
        "description": "Population model of the form A*exp(-B*t) + C",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "StructuredCoalescentTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.coalescent.StructuredCoalescentTree",
        "description": "A tree generated randomly from the structured coalescent process, with the given population sizes, migration rates and per-deme sample sizes.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree"
      },
      {
        "name": "ConstrainedClusterTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.ConstrainedClusterTree",
        "description": "Create initial beast.tree by hierarchical clustering, either through one of the classic link methods or by neighbor joining. The following link methods are supported: <br\/>o single link, <br\/>o complete link, <br\/>o UPGMA=average link, <br\/>o mean link, <br\/>o centroid, <br\/>o Ward and <br\/>o adjusted complete link <br\/>o neighborjoining <br\/>o neighborjoining2 - corrects tree for tip data, unlike plain neighborjoining",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "ConstrainedRandomTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.ConstrainedRandomTree",
        "description": "Random tree with constraints specified by one tree, just like multiple monophyly.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RandomTree"
      },
      {
        "name": "InitParamFromTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.InitParamFromTree",
        "description": "Sets values of a parameter from metadata values associated with a newick tree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "MonophyleticConstraint",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.MonophyleticConstraint",
        "description": "Enforces groups of taxa to be monophyletic -- have a common mrca that no other taxa have. This can be used as part of the prior. Multiple monophyletic constraints can be handled by adding one set per constraing.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "PrunedTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.PrunedTree",
        "description": "The binary tree generated by pruning a fixed subset of taxa from a source binary tree.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree"
      },
      {
        "name": "RNNIMetric",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.RNNIMetric",
        "description": "Ranked Nearest Neighbour Interchange metric on trees",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "TreeMetric"
        ]
      },
      {
        "name": "RobinsonsFouldMetric",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.RobinsonsFouldMetric",
        "description": "Robinson-Fould based tree metric",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "TreeMetric"
        ]
      },
      {
        "name": "SimpleConstrainedRandomTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.SimpleConstrainedRandomTree",
        "description": "Random tree with constraints specified by one tree, just like multiple monophyly.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SimpleRandomTree"
      },
      {
        "name": "SimplePrunedTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.SimplePrunedTree",
        "description": "The binary tree generated by pruning a fixed subset of taxa from a source binary tree. Supposed to be more robust but less efficient than PrunedTreeand not suitable for PrunedRelaxedClocks.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree"
      },
      {
        "name": "SimpleRandomTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.SimpleRandomTree",
        "description": "This class provides the basic engine for coalescent simulation of a given demographic model over a given time period. ",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "BernoulliDistribution",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.BernoulliDistribution",
        "description": "Bernoulli distribution, used as prior or likelihood.If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "BetaRange",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.BetaRange",
        "description": "Expansion of the Beta distribution, except it respects the upper\/lower limits of the parameter  Can handle a different prior per parameter if the dimension of 'x' is equal to the dimension of the gamma parameters  If alpha \/ beta are set to 0, then the parameter will be skipped (ie. 0 log density)  If the parameter exceeds lower\/upper, the log density is negative infinity",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "ExcludablePrior",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.ExcludablePrior",
        "description": "Just as with Prior, produces log probability of the parameter x. This variant however allows one to explicitly exclude individual elements of multidimensional parameters from the result.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Prior"
      },
      {
        "name": "ExcludablePriorIndex",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.ExcludablePriorIndex",
        "description": "Just as with Prior, produces log probability of the parameter x. This variant however allows one to explicitly exclude individual elements of multidimensional parameters from the result using indexes that can be set to true, rather than requiring a TRUE\/FALSe entry for each parameter index.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Prior"
      },
      {
        "name": "GammaOneP",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.GammaOneP",
        "description": "One parameter (shape) gamma distribution, used as prior. Scale = 1\/shape, so that mean = 1.If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "MixtureDistribution",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MixtureDistribution",
        "description": "Takes mixture of distributions",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "MonoPoints",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MonoPoints",
        "description": "Helper class for specifiying a set of monophyletic clades. This beast object is passed as an argument to another beast object, and provides the node id's of the clade roots upon request.The clades are collected from the various arguments and merged. Note that the mrca logger ignores the 'useOriginate' directive by design.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "MRCAPriorWithRogues",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MRCAPriorWithRogues",
        "description": "Allow some rogue taxa to enter a monophyletic constraint",
        "isAbstract": false,
        "isInterface": false,
        "extends": "MRCAPrior"
      },
      {
        "name": "MultiMonophyleticConstraint",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MultiMonophyleticConstraint",
        "description": "Prior over set of taxa, useful for defining multiple monophyletic constraints using a newick format",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "MultiMRCAPriors",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MultiMRCAPriors",
        "description": "A single distribution which efficiently takes care of a set of MRCA constraints.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "MultiMonophyleticConstraint"
      },
      {
        "name": "SingleParamGamma",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.SingleParamGamma",
        "description": "Gamma distribution in which the scale parameter is forced to equal the reciprocal of the shape parameter. This fixes the mean at 1.0.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "WeibullDistribution",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.WeibullDistribution",
        "description": "Weibull distribution. for x>0  f(x;shape,scale) = scale\/shape(x\/shape)^{scale-1}e^{-(x\/shape)^scale}",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "WeightedDirichlet",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.WeightedDirichlet",
        "description": "Weighted Dirichlet distribution that scales dimensions by weight",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "FitchParsimony",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.parsimony.FitchParsimony",
        "description": "Reconstructing characters using Fitch parsimony",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "PrevalenceLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.prevalence.PrevalenceLikelihood",
        "description": "likelihood of the prevalence sequence based on a set of parameters",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "PrevalenceList",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.prevalence.PrevalenceList",
        "description": "Prevalence list is a linked list with times and actions",
        "isAbstract": false,
        "isInterface": false,
        "extends": "StateNode"
      },
      {
        "name": "TreeForPrevalenceLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.prevalence.TreeForPrevalenceLikelihood",
        "description": "likelihood of a tree conditioned on a prevalence sequence",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "TraceStateNodeSource",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.tools.TraceStateNodeSource",
        "description": "Source of state node parameter values for post hoc analysis",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "TreeStateNodeSource",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.tools.TreeStateNodeSource",
        "description": "Source of trees for post hoc analysis",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "BEASTVector",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.BEASTVector",
        "description": "array of beast objects",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject",
        "collectionType": {
          "elementType": "Object",
          "kind": "vector"
        }
      },
      {
        "name": "Script",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Script",
        "description": "Base class for Script-BEAST interoperation",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "Transform.Array",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Array",
        "description": "Applies list of transforms to individual dimensions of a parameter",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.MultivariableTransformWithParameter"
      },
      {
        "name": "Transform.Collection",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Collection",
        "description": "Applies list of parsed transforms to segments (=contiguous subsets of dimensions?) of a parameter",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.MultivariableTransformWithParameter"
      },
      {
        "name": "Transform.Compose",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Compose",
        "description": "Composable transform: apply inner transforms first, then outer transform on the result",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "Transform.ComposeMultivariable",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$ComposeMultivariable",
        "description": "Composes transform by applying outer transform to inner transform",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.MultivariableTransform"
      },
      {
        "name": "Transform.FisherZTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$FisherZTransform",
        "description": "Fisher Z-transform for univariables",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "Transform.Inverse",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Inverse",
        "description": "Inverse transform for univariables",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "Transform.InverseMultivariate",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$InverseMultivariate",
        "description": "Inverse transforms multiple parameters or trees",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.MultivariateTransform"
      },
      {
        "name": "Transform.LogConstrainedSumTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$LogConstrainedSumTransform",
        "description": "Transform on parameters that sum to a fixed value (e.g. nucleotide frequencies)",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.MultivariableTransform"
      },
      {
        "name": "Transform.LogitTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$LogitTransform",
        "description": "Logit transform for univariables",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "Transform.LogTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$LogTransform",
        "description": "Log transform for univariables",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "Transform.NegateTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$NegateTransform",
        "description": "Negate transform for univariables",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "Transform.NoTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$NoTransform",
        "description": "No transform for univariables = transform that leaves the variable unchanged",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "Transform.NoTransformMultivariable",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$NoTransformMultivariable",
        "description": "Transform that leaves multi parameter the same",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.MultivariableTransform"
      },
      {
        "name": "Transform.PositiveOrdered",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$PositiveOrdered",
        "description": "Log transform on difference between consecutive entries. Entries must be increasing in order.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.MultivariateTransform"
      },
      {
        "name": "Transform.PowerTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$PowerTransform",
        "description": "Power transform for univariables",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Transform.UnivariableTransform"
      },
      {
        "name": "SampleTimeLog",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.core.SampleTimeLog",
        "description": "BEAST2 SampleTimeLog",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "SpeciesTreeLogger",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.core.SpeciesTreeLogger",
        "description": "Logs tree annotated with metadata in StarBeast format",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "StarBeastStartState",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.core.StarBeastStartState",
        "description": "Set a starting point for a *BEAST analysis from gene alignment data.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "RandomLocalClockModelSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.RandomLocalClockModelSB3",
        "description": "Based on RandomLocalClockModel in BEAST v2.4",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base",
        "implements": [
          "BranchRateModelSB3"
        ]
      },
      {
        "name": "SharedSpeciesClockModel",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.SharedSpeciesClockModel",
        "description": "BEAST2 SharedSpeciesClockModel",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "StarBeast3Clock",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.StarBeast3Clock",
        "description": "BEAST2 StarBeast3Clock",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base"
      },
      {
        "name": "StrictClockModelSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.StrictClockModelSB3",
        "description": "BEAST2 StrictClockModelSB3",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base",
        "implements": [
          "BranchRateModelSB3"
        ]
      },
      {
        "name": "UCRelaxedClockModelSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.UCRelaxedClockModelSB3",
        "description": "BEAST2 UCRelaxedClockModelSB3",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base",
        "implements": [
          "BranchRateModelSB3"
        ]
      },
      {
        "name": "BirthProcess",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.BirthProcess",
        "description": "Gene lineages are assumed to diverge under a speciation process, constrained within species tree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "PopulationModel"
        ]
      },
      {
        "name": "ConstantPopulations",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.ConstantPopulations",
        "description": "BEAST2 ConstantPopulations",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "PopulationModel"
        ]
      },
      {
        "name": "GeneTreeForSpeciesTreeDistribution",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.GeneTreeForSpeciesTreeDistribution",
        "description": "Calculates probability of gene tree conditioned on a species tree (multi-species coalescent)",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "SpeciesTreePrior",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.SpeciesTreePrior",
        "description": "Species tree prior for *BEAST analysis",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeDistribution"
      },
      {
        "name": "GeneTreeKernel",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GeneTreeKernel",
        "description": "BEAST2 GeneTreeKernel",
        "isAbstract": false,
        "isInterface": false,
        "extends": "StateNode"
      },
      {
        "name": "GTKGeneTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GTKGeneTree",
        "description": "BEAST2 GTKGeneTree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree"
      },
      {
        "name": "GTKPointerTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GTKPointerTree",
        "description": "BEAST2 GTKPointerTree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree"
      },
      {
        "name": "GTKPrior",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GTKPrior",
        "description": "BEAST2 GTKPrior",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "InverseGamma",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.math.distributions.InverseGamma",
        "description": "Inverse Gamma distribution, used as prior.    for x>0  f(x; alpha, beta) = \frac{beta^alpha}{Gamma(alpha)} (1\/x)^{alpha + 1}exp(-beta\/x) If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "MRCAPriorSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.math.distributions.MRCAPriorSB3",
        "description": "Behaves the same as a MRCAPrior, but allows BEAUti to know how to add the correct operators for tips sampling",
        "isAbstract": false,
        "isInterface": false,
        "extends": "MRCAPrior"
      },
      {
        "name": "BinaryNode",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.BinaryNode",
        "description": "BEAST2 BinaryNode",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Node"
      },
      {
        "name": "BinaryTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.BinaryTree",
        "description": "Binary tree with efficient store\/restore",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "TreeInterface"
        ]
      },
      {
        "name": "SpeciesTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.SpeciesTree",
        "description": "BEAST2 SpeciesTree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree"
      },
      {
        "name": "StarBeast3TaxonSet",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.StarBeast3TaxonSet",
        "description": "A TaxonSet is an ordered set of taxa. The order on the taxa is provided at the time of construction either from a list of taxon objects or an alignment.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TaxonSet"
      },
      {
        "name": "Function.Constant",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.core.Function$Constant",
        "description": "Function that does not change over time",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "VirtualBEASTObject",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.core.VirtualBEASTObject",
        "description": "BEAST Object that encapsulates an object that does not implement BEASTInterface",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "Alignment",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.Alignment",
        "description": "Class representing alignment data",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Map"
      },
      {
        "name": "AscertainedAlignment",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.AscertainedAlignment",
        "description": "Alignemnt that allows ascertainment correction",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Alignment"
      },
      {
        "name": "FilteredAlignment",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.FilteredAlignment",
        "description": "Alignment based on a filter operation on another alignment",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Alignment"
      },
      {
        "name": "Sequence",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.Sequence",
        "description": "Single sequence in an alignment.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "Taxon",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.Taxon",
        "description": "For identifying a single taxon",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "TaxonSet",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.TaxonSet",
        "description": "A TaxonSet is an ordered set of taxa. The order on the taxa is provided at the time of construction either from a list of taxon objects or an alignment.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Taxon"
      },
      {
        "name": "RandomLocalClockModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.RandomLocalClockModel",
        "description": "Random Local Clock Model.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base"
      },
      {
        "name": "StrictClockModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.StrictClockModel",
        "description": "Defines a mean rate for each branch in the beast.tree.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base"
      },
      {
        "name": "UCRelaxedClockModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.UCRelaxedClockModel",
        "description": "Defines an uncorrelated relaxed molecular clock.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BranchRateModel.Base"
      },
      {
        "name": "Aminoacid",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.Aminoacid",
        "description": "DataType for amino acids.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "DataType.Base"
      },
      {
        "name": "Binary",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.Binary",
        "description": "Datatype for binary sequences",
        "isAbstract": false,
        "isInterface": false,
        "extends": "DataType.Base"
      },
      {
        "name": "IntegerData",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.IntegerData",
        "description": "Datatype for integer sequences",
        "isAbstract": false,
        "isInterface": false,
        "extends": "DataType.Base"
      },
      {
        "name": "Nucleotide",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.Nucleotide",
        "description": "Nucleotide datatype for DNA sequences",
        "isAbstract": false,
        "isInterface": false,
        "extends": "DataType.Base"
      },
      {
        "name": "StandardData",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.StandardData",
        "description": "Integer data type to describe discrete morphological characters with polymorphisms",
        "isAbstract": false,
        "isInterface": false,
        "extends": "DataType.Base"
      },
      {
        "name": "TwoStateCovarion",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.TwoStateCovarion",
        "description": "Datatype for two state covarion sequences",
        "isAbstract": false,
        "isInterface": false,
        "extends": "DataType.Base"
      },
      {
        "name": "UserDataType",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.UserDataType",
        "description": "User defined datatype. Allows custom symbols to map onto statesets.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "DataType.Base"
      },
      {
        "name": "Distance.Base",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.Distance$Base",
        "description": "Provides distance between two sequences in an alignment",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "Distance"
        ]
      },
      {
        "name": "F84Distance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.F84Distance",
        "description": "compute HKY corrected distance",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distance.Base"
      },
      {
        "name": "HammingDistance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.HammingDistance",
        "description": "Hamming distance is the mean number of characters that differ between sequences. Note that unknowns are not ignored, so if both are unknowns '?' the distance is zero.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distance.Base"
      },
      {
        "name": "JukesCantorDistance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.JukesCantorDistance",
        "description": "compute jukes-cantor corrected distance",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distance.Base"
      },
      {
        "name": "SMMDistance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.SMMDistance",
        "description": "Calculate the distance between different microsatellite alleles",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distance.Base"
      },
      {
        "name": "BeagleTreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.BeagleTreeLikelihood",
        "description": "Uses Beagle library to calculate Tree likelihood",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeLikelihood"
      },
      {
        "name": "GenericTreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.GenericTreeLikelihood",
        "description": "Generic tree likelihood for an alignment given a generic SiteModel, a beast tree and a branch rate model",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "ThreadedTreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.ThreadedTreeLikelihood",
        "description": "Calculates the likelihood of sequence data on a beast.tree given a site and substitution model using a variant of the 'peeling algorithm'. For details, seeFelsenstein, Joseph (1981). Evolutionary trees from DNA sequences: a maximum likelihood approach. J Mol Evol 17 (6): 368-376.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GenericTreeLikelihood"
      },
      {
        "name": "TreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.TreeLikelihood",
        "description": "Calculates the probability of sequence data on a beast.tree given a site and substitution model using a variant of the 'peeling algorithm'. For details, seeFelsenstein, Joseph (1981). Evolutionary trees from DNA sequences: a maximum likelihood approach. J Mol Evol 17 (6): 368-376.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GenericTreeLikelihood"
      },
      {
        "name": "RateStatistic",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.RateStatistic",
        "description": "A statistic that tracks the mean, variance and coefficent of variation of rates. It has three dimensions, one for each statistic.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "SiteModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.sitemodel.SiteModel",
        "description": "Defines mutation rate and gamma distributed rates across sites (optional) and proportion of the sites invariant (also optional).",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SiteModelInterface.Base"
      },
      {
        "name": "BirthDeathGernhard08Model",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.BirthDeathGernhard08Model",
        "description": "Birth Death model based on Gernhard 2008. <br\/>This derivation conditions directly on fixed N taxa. <br\/>The inference is directly on b-d (strictly positive) and d\/b (constrained in [0,1)) <br\/>Verified using simulated trees generated by Klaas tree sample. (http:\/\/www.klaashartmann.com\/treesample\/) <br\/>Sampling proportion not verified via simulation. Proportion set by default to 1, an assignment which makes the expressions identical to the expressions before the change.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "YuleModel"
      },
      {
        "name": "CalibratedBirthDeathModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedBirthDeathModel",
        "description": "Birth-Death prior with calibrated monophyletic clades. With this prior, the marginal distribution of the calibrated nodes (the root age of the clade) is identical to the specified calibration, and the density ratio between trees with equal calibration values is equal to the ratio under the Birth-Death prior.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SpeciesTreeDistribution"
      },
      {
        "name": "CalibratedYuleInitialTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedYuleInitialTree",
        "description": "A tree compatible with a set of monophyletic clades and hard limits on the clade root.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "CalibratedYuleModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedYuleModel",
        "description": "Yule prior with calibrated monophyletic clades. With this prior, the marginal distribution of the calibrated nodes (the MRCA of clades) is identical to the specified calibration, but the Yule is not preserved over the whole tree space, only among sub-spaces.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SpeciesTreeDistribution"
      },
      {
        "name": "CalibrationPoint",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibrationPoint",
        "description": "Specification of a single calibration point of the calibrated Yule.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "GeneTreeForSpeciesTreeDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.GeneTreeForSpeciesTreeDistribution",
        "description": "Calculates probability of gene tree conditioned on a species tree (multi-species coalescent)",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeDistribution"
      },
      {
        "name": "RandomGeneTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.RandomGeneTree",
        "description": "Generates a random gene tree conditioned on a species tree, such that the root of the species tree is lower than any coalescent events in the gene tree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RandomTree"
      },
      {
        "name": "SpeciesTreeLogger",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.SpeciesTreeLogger",
        "description": "Logs tree annotated with metadata in StarBeast format",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "SpeciesTreePopFunction",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.SpeciesTreePopFunction",
        "description": "Species tree prior for *BEAST analysis",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeDistribution"
      },
      {
        "name": "SpeciesTreePrior",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.SpeciesTreePrior",
        "description": "Species tree prior for *BEAST analysis",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SpeciesTreePopFunction"
      },
      {
        "name": "StarBeastStartState",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.StarBeastStartState",
        "description": "Set a starting point for a *BEAST analysis from gene alignment data.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "TreeTopFinder",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.TreeTopFinder",
        "description": "Finds height of highest tree among a set of trees",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "YuleModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.YuleModel",
        "description": "Pure birth model (i.e. no deaths)",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SpeciesTreeDistribution"
      },
      {
        "name": "BinaryCovarion",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.BinaryCovarion",
        "description": "Covarion model for Binary data",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "Blosum62",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.Blosum62",
        "description": "BLOSUM62 model of amino acid evolution Henikoff, S., and J. G. Henikoff. 1992. PNAS USA 89:10915-10919.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "EmpiricalSubstitutionModel"
      },
      {
        "name": "ComplexSubstitutionModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.ComplexSubstitutionModel",
        "description": "Complex-diagonalizable, irreversible substitution model",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "CPREV",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.CPREV",
        "description": " CPREV 45 model of amino acid evolution  Adachi, J., P.J. Waddell, W. Martin, and M. Hasegawa. 2000. JME 50:348-358",
        "isAbstract": false,
        "isInterface": false,
        "extends": "EmpiricalSubstitutionModel"
      },
      {
        "name": "Dayhoff",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.Dayhoff",
        "description": " Dayhoff model for amino acid evolution  Dayhoff, M.O., Schwartz, R.M., Orcutt, B.C. (1978)  A model of evolutionary change in proteins.  Dayhoff, M.O. (ed.) Atlas of Protein Sequence Structur., Vol5, Suppl. 3,  National Biomedical Research Foundation, Washington DC, pp. 345-352.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "EmpiricalSubstitutionModel"
      },
      {
        "name": "Frequencies",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.Frequencies",
        "description": "Represents character frequencies typically used as distribution of the root of the tree. Calculates empirical frequencies of characters in sequence data, or simply assumes a uniform distribution if the estimate flag is set to false.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "GeneralSubstitutionModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.GeneralSubstitutionModel",
        "description": "Specifies transition probability matrix with no restrictions on the rates other than that one of the is equal to one and the others are specified relative to this unit rate. Works for any number of states.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SubstitutionModel.Base"
      },
      {
        "name": "GTR",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.GTR",
        "description": "General Time Reversible model of nucleotide evolution. Rates that are not specified are assumed to be 1. ",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "HKY",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.HKY",
        "description": "HKY85 (Hasegawa, Kishino & Yano, 1985) substitution model of nucleotide evolution.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SubstitutionModel.NucleotideBase"
      },
      {
        "name": "JTT",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.JTT",
        "description": " * JTT model for amino acid evolution  D.T. Jones, W.R. Taylor, and J.M. Thornton  The rapid generation of mutation data matrices from protein sequences  CABIOS  vol. 8 no. 3 1992 pp. 275-282.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "EmpiricalSubstitutionModel"
      },
      {
        "name": "JukesCantor",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.JukesCantor",
        "description": "Jukes Cantor substitution model: all rates equal and uniformly distributed frequencies",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SubstitutionModel.Base"
      },
      {
        "name": "MTREV",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.MTREV",
        "description": "MTREV24 model of amino acid evolution  (complete sequence data of mtDNA from 24 vertebrate species)  Adachi, J., and Hasegawa, M. 1996. J. Mol. Evol. 42:459-468.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "EmpiricalSubstitutionModel"
      },
      {
        "name": "MutationDeathModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.MutationDeathModel",
        "description": "Mutation Death substitution model, can be used as Stochastic Dollo model.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SubstitutionModel.Base"
      },
      {
        "name": "SYM",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.SYM",
        "description": "Symmetrical model of nucleotide evolution with equal base frequencies.Rates that are not specified are assumed to be 1.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "TIM",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.TIM",
        "description": "Transition model of nucleotide evolution (variable transition rates, two transversion rates). Rates that are not specified are assumed to be 1.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "TN93",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.TN93",
        "description": "TN93 (Tamura and Nei, 1993) substitution model of nucleotide evolution.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "SubstitutionModel.NucleotideBase"
      },
      {
        "name": "TVM",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.TVM",
        "description": "Transversion model of nucleotide evolution (variable transversion rates, equal transition rates).Rates that are not specified are assumed to be 1.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralSubstitutionModel"
      },
      {
        "name": "WAG",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.WAG",
        "description": "WAG model of amino acid evolution by S. Whelan and N. Goldman. 2001. Molecular biology and evolution 18.5 (2001): 691-699 ",
        "isAbstract": false,
        "isInterface": false,
        "extends": "EmpiricalSubstitutionModel"
      },
      {
        "name": "Sum",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.Sum",
        "description": "calculates sum of a valuable",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "ClusterTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.ClusterTree",
        "description": "Create initial beast.tree by hierarchical clustering, either through one of the classic link methods or by neighbor joining. The following link methods are supported: <br\/>o single link, <br\/>o complete link, <br\/>o UPGMA=average link, <br\/>o mean link, <br\/>o centroid, <br\/>o Ward and <br\/>o adjusted complete link <br\/>o neighborjoining <br\/>o neighborjoining2 - corrects tree for tip data, unlike plain neighborjoining",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "BayesianSkyline",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.BayesianSkyline",
        "description": "Bayesian skyline: A likelihood function for the generalized skyline plot coalescent.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeDistribution"
      },
      {
        "name": "Coalescent",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.Coalescent",
        "description": "Calculates the probability of a beast.tree conditional on a population size function. Note that this does not take the number of possible tree interval\/tree topology combinations in account, in other words, the constant required for making this a proper distribution that integrates to unity is not calculated (partly, because we don't know how for sequentially sampled data).",
        "isAbstract": false,
        "isInterface": false,
        "extends": "TreeDistribution"
      },
      {
        "name": "CompoundPopulationFunction",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.CompoundPopulationFunction",
        "description": "An effective population size function based on coalecent times from a set of trees.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "ConstantPopulation",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.ConstantPopulation",
        "description": "coalescent intervals for a constant population",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "ExponentialGrowth",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.ExponentialGrowth",
        "description": "Coalescent intervals for a exponentially growing population.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "RandomTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.RandomTree",
        "description": "This class provides the basic engine for coalescent simulation of a given demographic model over a given time period. ",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "ScaledPopulationFunction",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.ScaledPopulationFunction",
        "description": "Scale a demographic function by a constant factor",
        "isAbstract": false,
        "isInterface": false,
        "extends": "PopulationFunction.Abstract"
      },
      {
        "name": "MRCAPrior",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.MRCAPrior",
        "description": "Prior over set of taxa, useful for defining monophyletic constraints and distributions over MRCA times or (sets of) tips of trees. Be aware that the distribution is in units equal to that used in the tree: if the tree has intenal node heights representing age, the distribution represents age, if the tree is in units of a date since some time in the past (e.g. if tip dates are added) the distribution is in units of date since some time in the past.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "Node",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.Node",
        "description": "Nodes in building beast.tree data structure.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "TraitSet",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.TraitSet",
        "description": "A trait set represent a collection of properties of taxons, for the use of initializing a tree. The traits are represented as text content in taxon=value form, for example, for a date trait, wecould have a content of chimp=1950,human=1991,neander=-10000. All white space is ignored, so they canbe put on multiple tabbed lines in the XML. The type of node in the tree determines what happes with this information. The default Node only recognizes 'date', 'date-forward' and 'date-backward' as a trait, but by creating custom Node classes other traits can be supported as well.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "Tree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.Tree",
        "description": "Tree (the T in BEAST) representing gene beast.tree, species beast.tree, language history, or other time-beast.tree relationships among sequence data.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "StateNode",
        "implements": [
          "TreeInterface"
        ]
      },
      {
        "name": "TreeIntervals",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeIntervals",
        "description": "Extracts the intervals from a tree. Points in the intervals are defined by the heights of nodes in the tree.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode"
      },
      {
        "name": "TreeParser",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeParser",
        "description": "Create beast.tree by parsing from a specification of a beast.tree in Newick format (includes parsing of any meta data in the Newick string).",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree",
        "implements": [
          "StateNodeInitialiser"
        ]
      },
      {
        "name": "CompoundDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.CompoundDistribution",
        "description": "Takes a collection of distributions, typically a number of likelihoods and priors and combines them into the compound of these distributions typically interpreted as the posterior.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "Beta",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Beta",
        "description": "Beta distribution, used as prior.  p(x;alpha,beta) = \frac{x^{alpha-1}(1-x)^{beta-1}} {B(alpha,beta)} where B() is the beta function. If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "ChiSquare",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.ChiSquare",
        "description": "Chi square distribution, f(x; k) = \\frac{1}{2^{k\/2}Gamma(k\/2)} x^{k\/2-1} e^{-x\/2} If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "Dirichlet",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Dirichlet",
        "description": "Dirichlet distribution.  p(x_1,...,x_n;alpha_1,...,alpha_n) = 1\/B(alpha) prod_{i=1}^K x_i^{alpha_i - 1} where B() is the beta function B(alpha) = prod_{i=1}^K Gamma(alpha_i)\/ Gamma(sum_{i=1}^K alpha_i}. ",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "Exponential",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Exponential",
        "description": "Exponential distribution.  f(x;\\lambda) = 1\/\\lambda e^{-x\/\\lambda}, if x >= 0 If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "Gamma",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Gamma",
        "description": "Gamma distribution. for x>0  g(x;alpha,beta) = 1\/Gamma(alpha) beta^alpha} x^{alpha - 1} e^{-\frac{x}{beta}}If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "InverseGamma",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.InverseGamma",
        "description": "Inverse Gamma distribution, used as prior.    for x>0  f(x; alpha, beta) = \frac{beta^alpha}{Gamma(alpha)} (1\/x)^{alpha + 1}exp(-beta\/x) If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "LaplaceDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.LaplaceDistribution",
        "description": "Laplace distribution.    f(x|\\mu,b) = \\frac{1}{2b} \\exp \\left( -\\frac{|x-\\mu|}{b} \\right)The probability density function of the Laplace distribution is also reminiscent of the normal distribution; however, whereas the normal distribution is expressed in terms of the squared difference from the mean ?, the Laplace density is expressed in terms of the absolute difference from the mean. Consequently the Laplace distribution has fatter tails than the normal distribution.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "LogNormalDistributionModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.LogNormalDistributionModel",
        "description": "A log-normal distribution with mean and variance parameters.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "MarkovChainDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.MarkovChainDistribution",
        "description": "A class that produces a distribution chaining values in a parameter through the Gamma distribution. The value of a parameter is assumed to be Gamma distributed with mean as the previous value in the parameter. If useLogNormal is set, a log normal distribution is used instead of a Gamma. If a Jeffrey's prior is used, the first value is assumed to be distributed as 1\/x, otherwise it is assumed to be uniform. Handy for population parameters. ",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "Normal",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Normal",
        "description": "Normal distribution.  f(x) = frac{1}{\\sqrt{2\\pi\\sigma^2}} e^{ -\\frac{(x-\\mu)^2}{2\\sigma^2} } If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "OneOnX",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.OneOnX",
        "description": "OneOnX distribution.  f(x) = C\/x for some normalizing constant C. If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "Poisson",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Poisson",
        "description": "Poisson distribution, used as prior  f(k; lambda)=\\frac{lambda^k e^{-lambda}}{k!}  If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "Prior",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Prior",
        "description": "Produces prior (log) probability of value x.If x is multidimensional, the components of x are assumed to be independent, so the sum of log probabilities of all elements of x is returned as the prior.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Distribution"
      },
      {
        "name": "Uniform",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Uniform",
        "description": "Uniform distribution over a given interval (including lower and upper values)",
        "isAbstract": false,
        "isInterface": false,
        "extends": "ParametricDistribution"
      },
      {
        "name": "BooleanParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.BooleanParameter",
        "description": "A Boolean-valued parameter represents a value (or array of values if the dimension is larger than one) in the state space that can be changed by operators.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Parameter.Base",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Boolean"
        ]
      },
      {
        "name": "BooleanParameterList",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.BooleanParameterList",
        "description": "State node describing a list of boolean parameters.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralParameterList"
      },
      {
        "name": "CompoundRealParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.CompoundRealParameter",
        "description": "Parmeter consisting of 2 or more RealParameters but behaving like a single RealParameter",
        "isAbstract": false,
        "isInterface": false,
        "extends": "RealParameter",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "CompoundValuable",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.CompoundValuable",
        "description": "Summarizes a set of valuables so that for example a rate matrix can be specified that uses a parameter in various places in the matrix.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "IntegerParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.IntegerParameter",
        "description": "An integer-valued parameter represents a value (or array of values if the dimension is larger than one) in the state space that can be changed by operators.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Parameter.Base",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Integer",
          "Long"
        ]
      },
      {
        "name": "IntegerParameterList",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.IntegerParameterList",
        "description": "State node describing a list of integer-valued parameters.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralParameterList"
      },
      {
        "name": "RealParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.RealParameter",
        "description": "A real-valued parameter represents a value (or array of values if the dimension is larger than one) in the state space that can be changed by operators.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Parameter.Base",
        "primitiveAssignable": true,
        "acceptedPrimitives": [
          "Double",
          "Float"
        ]
      },
      {
        "name": "RealParameterList",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.RealParameterList",
        "description": "State node describing a list of real-valued parameters.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "GeneralParameterList"
      },
      {
        "name": "State",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.State",
        "description": "The state represents the current point in the state space, and maintains values of a set of StateNodes, such as parameters and trees. Furthermore, the state manages which parts of the model need to be stored\/restored and notified that recalculation is appropriate.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "ESS",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.util.ESS",
        "description": "Report effective sample size of a parameter or log values from a distribution. This uses the same criterion as Tracer and assumes 10% burn in.",
        "isAbstract": false,
        "isInterface": false,
        "extends": "BEASTObject"
      },
      {
        "name": "RPNcalculator",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.util.RPNcalculator",
        "description": "RPN calculator to evaluate simple expressions of parameters (Reverse Polish notation is a mathematical notation wherein every operator follows its operands)",
        "isAbstract": false,
        "isInterface": false,
        "extends": "CalculationNode",
        "implements": [
          "Function"
        ]
      },
      {
        "name": "FilteredTree",
        "package": "CCD",
        "fullyQualifiedName": "ccd.model.FilteredTree",
        "description": "BEAST2 FilteredTree",
        "isAbstract": false,
        "isInterface": false,
        "extends": "Tree"
      },
      {
        "name": "ThreadedTreeLikelihood.Scaling",
        "package": "beast.base.evolution.likelihood",
        "fullyQualifiedName": "beast.base.evolution.likelihood.ThreadedTreeLikelihood$Scaling",
        "description": "Enum type for ThreadedTreeLikelihood",
        "isEnum": true,
        "values": [
          "none",
          "always",
          "_default"
        ]
      },
      {
        "name": "StarBeastStartState.Method",
        "package": "starbeast3.core",
        "fullyQualifiedName": "starbeast3.core.StarBeastStartState$Method",
        "description": "Enum type for StarBeastStartState",
        "isEnum": true,
        "values": [
          "point-estimate",
          "fixed",
          "random"
        ]
      },
      {
        "name": "CalibratedYuleModel.Type",
        "package": "beast.base.evolution.speciation",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedYuleModel$Type",
        "description": "Enum type for CalibratedYuleModel",
        "isEnum": true,
        "values": [
          "none",
          "full",
          "restricted"
        ]
      },
      {
        "name": "ConstrainedClusterTree.Type",
        "package": "beastlabs.evolution.tree",
        "fullyQualifiedName": "beastlabs.evolution.tree.ConstrainedClusterTree$Type",
        "description": "Enum type for ConstrainedClusterTree",
        "isEnum": true,
        "values": [
          "single",
          "average",
          "complete",
          "upgma",
          "mean",
          "centroid",
          "ward",
          "adjcomplete",
          "neighborjoining",
          "neighborjoining2"
        ]
      },
      {
        "name": "TreeLikelihood.Scaling",
        "package": "beast.base.evolution.likelihood",
        "fullyQualifiedName": "beast.base.evolution.likelihood.TreeLikelihood$Scaling",
        "description": "Enum type for TreeLikelihood",
        "isEnum": true,
        "values": [
          "none",
          "always",
          "_default"
        ]
      },
      {
        "name": "TraitSet.Units",
        "package": "beast.base.evolution.tree",
        "fullyQualifiedName": "beast.base.evolution.tree.TraitSet$Units",
        "description": "Enum type for TraitSet",
        "isEnum": true,
        "values": [
          "year",
          "month",
          "day"
        ]
      },
      {
        "name": "CalibratedBirthDeathModel.Type",
        "package": "beast.base.evolution.speciation",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedBirthDeathModel$Type",
        "description": "Enum type for CalibratedBirthDeathModel",
        "isEnum": true,
        "values": [
          "none",
          "full",
          "restricted"
        ]
      },
      {
        "name": "BinaryCovarion.MODE",
        "package": "beast.base.evolution.substitutionmodel",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.BinaryCovarion$MODE",
        "description": "Enum type for BinaryCovarion",
        "isEnum": true,
        "values": [
          "BEAST",
          "REVERSIBLE",
          "TUFFLEYSTEEL"
        ]
      },
      {
        "name": "ClusterTree.Type",
        "package": "beast.base.evolution.tree",
        "fullyQualifiedName": "beast.base.evolution.tree.ClusterTree$Type",
        "description": "Enum type for ClusterTree",
        "isEnum": true,
        "values": [
          "single",
          "average",
          "complete",
          "upgma",
          "mean",
          "centroid",
          "ward",
          "adjcomplete",
          "neighborjoining",
          "neighborjoining2"
        ]
      },
      {
        "name": "Gamma.mode",
        "package": "beast.base.inference.distribution",
        "fullyQualifiedName": "beast.base.inference.distribution.Gamma$mode",
        "description": "Enum type for Gamma",
        "isEnum": true,
        "values": [
          "ShapeScale",
          "ShapeRate",
          "ShapeMean",
          "OneParameter"
        ]
      }
    ],
    "generators": [
      {
        "name": "TreeDistribution",
        "package": "beast.base.evolution.tree",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeDistribution",
        "description": "Distribution on a tree, typically a prior such as Coalescent or Yule",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "ExpCalculator",
        "package": "feast",
        "fullyQualifiedName": "feast.expressions.ExpCalculator",
        "description": "Evaluates simple expressions of parameters involving parameters, including parameters of different lengths.  Individual elements of parameters can be specified using [] notation.  Parameters with differing dimension are combined as in R, with the shortest  parameter being repeated as many times as necessary.",
        "generatorType": "function",
        "generatedType": "ExpCalculator",
        "arguments": [
          {
            "name": "value",
            "type": "String",
            "description": "Expression needed for calculations.",
            "required": true
          },
          {
            "name": "arg",
            "type": "List<Function>",
            "description": "Parameters\/functions needed for the calculation",
            "required": false,
            "default": "[]"
          },
          {
            "name": "useCaching",
            "type": "Boolean",
            "description": "Set to false to disable caching of function values. (This can be useful when using ExpCalculator exclusively for logging.) Default true.",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "ExpCalculatorDistribution",
        "package": "feast",
        "fullyQualifiedName": "feast.expressions.ExpCalculatorDistribution",
        "description": "A distribution composed from an expression string.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "value",
            "type": "String",
            "description": "Expression needed for calculations.",
            "required": true
          },
          {
            "name": "arg",
            "type": "List<Function>",
            "description": "Parameters\/functions needed for the calculation",
            "required": false,
            "default": "[]"
          },
          {
            "name": "isLog",
            "type": "Boolean",
            "description": "True if expression represents log(P), false if it represents P. Default is false.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "ExpCalculatorParametricDistribution",
        "package": "feast",
        "fullyQualifiedName": "feast.expressions.ExpCalculatorParametricDistribution",
        "description": "Expression calculator distribution for use with the Prior class.  This is a somewhat restricted version of ExpCalculatorDistribution as it does not allow for general multivariate distributions.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "value",
            "type": "String",
            "description": "Expression needed for calculations.",
            "required": true
          },
          {
            "name": "isLog",
            "type": "Boolean",
            "description": "True if expression represents log(P), false if it represents P. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "AlignmentFromFasta",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.AlignmentFromFasta",
        "description": "Objects of this type are regular beast Alignments, but are populated using data read in from an external fasta file.  Sequence labels used as taxon labels.",
        "generatorType": "function",
        "generatedType": "AlignmentFromFasta",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of file containing sequence alignment.",
            "required": false
          },
          {
            "name": "url",
            "type": "String",
            "description": "URL from which to download sequence alignment.",
            "required": false
          },
          {
            "name": "xmlFileName",
            "type": "String",
            "description": "Name of file to write XML fragment to.",
            "required": false
          },
          {
            "name": "endsWith",
            "type": "String",
            "description": "If provided, include only those sequences whose header strings end with the provided substring.",
            "required": false
          },
          {
            "name": "includeOnly",
            "type": "TaxonSet",
            "description": "Only include the taxa listed in this taxon set.",
            "required": false
          },
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "AlignmentFromFile",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.AlignmentFromFile",
        "description": "BEAST2 AlignmentFromFile",
        "generatorType": "function",
        "generatedType": "AlignmentFromFile",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of file containing sequence alignment.",
            "required": false
          },
          {
            "name": "url",
            "type": "String",
            "description": "URL from which to download sequence alignment.",
            "required": false
          },
          {
            "name": "xmlFileName",
            "type": "String",
            "description": "Name of file to write XML fragment to.",
            "required": false
          },
          {
            "name": "endsWith",
            "type": "String",
            "description": "If provided, include only those sequences whose header strings end with the provided substring.",
            "required": false
          },
          {
            "name": "includeOnly",
            "type": "TaxonSet",
            "description": "Only include the taxa listed in this taxon set.",
            "required": false
          },
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "AlignmentFromNexus",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.AlignmentFromNexus",
        "description": "Objects of this type are regular beast Alignments, but are populated using data read in from an external NEXUS file.  Sequence labels used as taxon labels.",
        "generatorType": "function",
        "generatedType": "AlignmentFromNexus",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of file containing sequence alignment.",
            "required": false
          },
          {
            "name": "url",
            "type": "String",
            "description": "URL from which to download sequence alignment.",
            "required": false
          },
          {
            "name": "xmlFileName",
            "type": "String",
            "description": "Name of file to write XML fragment to.",
            "required": false
          },
          {
            "name": "endsWith",
            "type": "String",
            "description": "If provided, include only those sequences whose header strings end with the provided substring.",
            "required": false
          },
          {
            "name": "includeOnly",
            "type": "TaxonSet",
            "description": "Only include the taxa listed in this taxon set.",
            "required": false
          },
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "DummyPosterior",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.DummyPosterior",
        "description": "BEAST2 DummyPosterior",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "object",
            "type": "List<BEASTInterface>",
            "description": "Dummy posterior input.",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "LogFileRealParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.LogFileRealParameter",
        "description": "Represents a RealParameter to be read in from a log file as part of a LogFileIterator run.",
        "generatorType": "function",
        "generatedType": "LogFileRealParameter",
        "arguments": [
          {
            "name": "fieldName",
            "type": "String",
            "description": "Name of field in log file.",
            "required": true
          },
          {
            "name": "fieldParameter",
            "type": "RealParameter",
            "description": "Parameter with which to associate log file entry values.",
            "required": true
          },
          {
            "name": "fieldParameterIndex",
            "type": "Integer",
            "description": "Index of element in parameter to initialize with field value.",
            "required": false,
            "default": "0"
          }
        ]
      },
      {
        "name": "TraceLogFileState",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.TraceLogFileState",
        "description": "A LogFileState representing the mapping from input trace log file samples to BEAST 2 Parameters.",
        "generatorType": "function",
        "generatedType": "TraceLogFileState",
        "arguments": [
          {
            "name": "logFileEntry",
            "type": "List<LogFileRealParameter>",
            "description": "Associates column of logfile with BEASTObject",
            "required": false,
            "default": "[]"
          },
          {
            "name": "logFileName",
            "type": "String",
            "description": "Name of log file",
            "required": true
          }
        ]
      },
      {
        "name": "TreeLogFileState",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.logfileiterator.TreeLogFileState",
        "description": "A LogFileState representing the mapping from input tree log file samples to BEAST 2 Trees.",
        "generatorType": "function",
        "generatedType": "TreeLogFileState",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "Tree to read log file state into.",
            "required": true
          },
          {
            "name": "readTaxonSet",
            "type": "Boolean",
            "description": "Read taxon set from tree file and assign to each tree.",
            "required": false,
            "default": "true"
          },
          {
            "name": "logFileName",
            "type": "String",
            "description": "Name of log file",
            "required": true
          }
        ]
      },
      {
        "name": "RealParameterFromLabelledXSV",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.RealParameterFromLabelledXSV",
        "description": "Initializes a RealParameter with values read from a CSV\/TSV file in row-major order.",
        "generatorType": "function",
        "generatedType": "RealParameterFromLabelledXSV",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of CSV\/TSV file to extract values from.",
            "required": true
          },
          {
            "name": "sep",
            "type": "String",
            "description": "Separator for CSV\/TSV file.  Default is TAB.",
            "required": false,
            "default": "\t"
          },
          {
            "name": "rowLabels",
            "type": "String",
            "description": "Labels of rows to include. (Default all.)",
            "required": false
          },
          {
            "name": "colLabels",
            "type": "String",
            "description": "Labels of columns to include. (Default all.)",
            "required": false
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "RealParameterFromXSV",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.RealParameterFromXSV",
        "description": "Initializes a RealParameter with values read from a CSV\/TSV file in row-major order.",
        "generatorType": "function",
        "generatedType": "RealParameterFromXSV",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of CSV\/TSV file to extract values from.",
            "required": true
          },
          {
            "name": "sep",
            "type": "String",
            "description": "Separator for CSV\/TSV file.  Default is TAB.",
            "required": false,
            "default": "\t"
          },
          {
            "name": "startRow",
            "type": "Integer",
            "description": "First row to include in the parameter. (Default 0.)",
            "required": false,
            "default": "0"
          },
          {
            "name": "rowCount",
            "type": "Integer",
            "description": "Maximum number of rows to include. (Default all.)",
            "required": false,
            "default": "2147483647",
            "constraint": "positive-integer"
          },
          {
            "name": "startCol",
            "type": "Integer",
            "description": "First column to include in the parameter. (Default 0.)",
            "required": false,
            "default": "0"
          },
          {
            "name": "colCount",
            "type": "Integer",
            "description": "Maximum number of columns to include. (Default all.)",
            "required": false,
            "default": "2147483647",
            "constraint": "positive-integer"
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "TaxonSetFromTree",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TaxonSetFromTree",
        "description": "Represents a TaxonSet object where the taxon names are extracted from the given tree.",
        "generatorType": "function",
        "generatedType": "TaxonSetFromTree",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "Tree from which to take taxon set.",
            "required": true
          },
          {
            "name": "alignment",
            "type": "Alignment",
            "description": "alignment where each sequence represents a taxon",
            "required": false
          },
          {
            "name": "taxon",
            "type": "List<Taxon>",
            "description": "list of taxa making up the set",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "TipDatesFromTree",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TipDatesFromTree",
        "description": "Traitset for tip dates obtained from input tree",
        "generatorType": "function",
        "generatedType": "TipDatesFromTree",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "Tree from which to extract tip dates.",
            "required": true
          },
          {
            "name": "traitname",
            "type": "String",
            "description": "name of the trait, used as meta data name for the tree. Special traitnames that are recognized are 'age','date','date-forward' and 'date-backward'.",
            "required": false
          },
          {
            "name": "units",
            "type": "TraitSet.Units",
            "description": "name of the units in which values are posed, used for conversion to a real value. This can be [year, month, day] (default 'year')",
            "required": false,
            "default": "year"
          },
          {
            "name": "value",
            "type": "String",
            "description": "traits encoded as taxon=value pairs separated by commas",
            "required": false
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "contains list of taxa to map traits to",
            "required": true
          },
          {
            "name": "dateFormat",
            "type": "String",
            "description": "the date\/time format to be parsed, (e.g., 'dd\/M\/yyyy')",
            "required": false
          }
        ]
      },
      {
        "name": "TraitSetFromTaxonSet",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TraitSetFromTaxonSet",
        "description": "Initialize a trait set from a taxon set. Permits similar functionality to the 'autoconfigure' option in BEAUti.",
        "generatorType": "function",
        "generatedType": "TraitSetFromTaxonSet",
        "arguments": [
          {
            "name": "delimiter",
            "type": "String",
            "description": "Delimiter used to split taxon names.",
            "required": true
          },
          {
            "name": "everythingBeforeFirst",
            "type": "Boolean",
            "description": "Use everything before this delimiter.",
            "required": false,
            "default": "false"
          },
          {
            "name": "everythingAfterLast",
            "type": "Boolean",
            "description": "Use everything before this delimiter.",
            "required": false,
            "default": "false"
          },
          {
            "name": "takeGroup",
            "type": "Integer",
            "description": "Use everthing in this group.",
            "required": false,
            "default": "-1"
          },
          {
            "name": "traitname",
            "type": "String",
            "description": "name of the trait, used as meta data name for the tree. Special traitnames that are recognized are 'age','date','date-forward' and 'date-backward'.",
            "required": true
          },
          {
            "name": "units",
            "type": "TraitSet.Units",
            "description": "name of the units in which values are posed, used for conversion to a real value. This can be [year, month, day] (default 'year')",
            "required": false,
            "default": "year"
          },
          {
            "name": "value",
            "type": "String",
            "description": "traits encoded as taxon=value pairs separated by commas",
            "required": false
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "contains list of taxa to map traits to",
            "required": true
          },
          {
            "name": "dateFormat",
            "type": "String",
            "description": "the date\/time format to be parsed, (e.g., 'dd\/M\/yyyy')",
            "required": false
          }
        ]
      },
      {
        "name": "TraitSetFromXSV",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TraitSetFromXSV",
        "description": "Initialize a trait set from a CSV\/TSV file.",
        "generatorType": "function",
        "generatedType": "TraitSetFromXSV",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of CSV\/TSV file to extract values from.",
            "required": true
          },
          {
            "name": "sep",
            "type": "String",
            "description": "Separator for CSV\/TSV file.  Default is TAB.",
            "required": false,
            "default": "\t"
          },
          {
            "name": "taxonNameCol",
            "type": "Integer",
            "description": "Index of column containing taxon names (Default 0).",
            "required": false,
            "default": "0"
          },
          {
            "name": "traitValueCol",
            "type": "Integer",
            "description": "Index of column containing trait names (Default 1).",
            "required": false,
            "default": "1"
          },
          {
            "name": "skipFirstRow",
            "type": "Boolean",
            "description": "If true, skip first row. (Default false.)",
            "required": false,
            "default": "false"
          },
          {
            "name": "traitname",
            "type": "String",
            "description": "name of the trait, used as meta data name for the tree. Special traitnames that are recognized are 'age','date','date-forward' and 'date-backward'.",
            "required": true
          },
          {
            "name": "units",
            "type": "TraitSet.Units",
            "description": "name of the units in which values are posed, used for conversion to a real value. This can be [year, month, day] (default 'year')",
            "required": false,
            "default": "year"
          },
          {
            "name": "value",
            "type": "String",
            "description": "traits encoded as taxon=value pairs separated by commas",
            "required": false
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "contains list of taxa to map traits to",
            "required": true
          },
          {
            "name": "dateFormat",
            "type": "String",
            "description": "the date\/time format to be parsed, (e.g., 'dd\/M\/yyyy')",
            "required": false
          }
        ]
      },
      {
        "name": "TreeFromNewickFile",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TreeFromNewickFile",
        "description": "Wrapper around TreeParser to enable reading newick strings from files.",
        "generatorType": "function",
        "generatedType": "TreeFromNewickFile",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of file containing tree in Newick format.",
            "required": true
          },
          {
            "name": "treeIndex",
            "type": "Integer",
            "description": "Index of tree in tree file (default 0).",
            "required": false,
            "default": "0"
          },
          {
            "name": "IsLabelledNewick",
            "type": "Boolean",
            "description": "Is the newick tree labelled (alternatively contains node numbers)? Default=false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "Specifies the list of taxa represented by leaves in the beast.tree",
            "required": false
          },
          {
            "name": "newick",
            "type": "String",
            "description": "initial beast.tree represented in newick format",
            "required": false
          },
          {
            "name": "offset",
            "type": "Integer",
            "description": "offset if numbers are used for taxa (offset=the lowest taxa number) default=1",
            "required": false,
            "default": "1"
          },
          {
            "name": "threshold",
            "type": "Double",
            "description": "threshold under which node heights (derived from lengths) are set to zero. Default=0.",
            "required": false,
            "default": "0.0"
          },
          {
            "name": "singlechild",
            "type": "Boolean",
            "description": "flag to indicate that single child nodes are allowed. Default=true.",
            "required": false,
            "default": "true"
          },
          {
            "name": "adjustTipHeights",
            "type": "Boolean",
            "description": "flag to indicate if tipHeights shall be adjusted when date traits missing. Default=true.",
            "required": false,
            "default": "true"
          },
          {
            "name": "scale",
            "type": "Double",
            "description": "scale used to multiply internal node heights during parsing. Useful for importing starting from external programs, for instance, RaxML tree rooted using Path-o-gen.",
            "required": false,
            "default": "1.0",
            "constraint": "positive"
          },
          {
            "name": "binarizeMultifurcations",
            "type": "Boolean",
            "description": "Whether or not to turn multifurcations into sequences of bifurcations. (Default true.)",
            "required": false,
            "default": "true"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "TreeFromNexusFile",
        "package": "feast",
        "fullyQualifiedName": "feast.fileio.TreeFromNexusFile",
        "description": "Wrapper around TreeParser to enable reading trees from Nexus files.",
        "generatorType": "function",
        "generatedType": "TreeFromNexusFile",
        "arguments": [
          {
            "name": "fileName",
            "type": "String",
            "description": "Name of Nexus file containing a tree block Nexus format.",
            "required": true
          },
          {
            "name": "treeIndex",
            "type": "Integer",
            "description": "Index of tree in tree file (default 0).",
            "required": false,
            "default": "0"
          },
          {
            "name": "IsLabelledNewick",
            "type": "Boolean",
            "description": "Is the newick tree labelled (alternatively contains node numbers)? Default=false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "Specifies the list of taxa represented by leaves in the beast.tree",
            "required": false
          },
          {
            "name": "newick",
            "type": "String",
            "description": "initial beast.tree represented in newick format",
            "required": false
          },
          {
            "name": "offset",
            "type": "Integer",
            "description": "offset if numbers are used for taxa (offset=the lowest taxa number) default=1",
            "required": false,
            "default": "1"
          },
          {
            "name": "threshold",
            "type": "Double",
            "description": "threshold under which node heights (derived from lengths) are set to zero. Default=0.",
            "required": false,
            "default": "0.0"
          },
          {
            "name": "singlechild",
            "type": "Boolean",
            "description": "flag to indicate that single child nodes are allowed. Default=true.",
            "required": false,
            "default": "true"
          },
          {
            "name": "adjustTipHeights",
            "type": "Boolean",
            "description": "flag to indicate if tipHeights shall be adjusted when date traits missing. Default=true.",
            "required": false,
            "default": "true"
          },
          {
            "name": "scale",
            "type": "Double",
            "description": "scale used to multiply internal node heights during parsing. Useful for importing starting from external programs, for instance, RaxML tree rooted using Path-o-gen.",
            "required": false,
            "default": "1.0",
            "constraint": "positive"
          },
          {
            "name": "binarizeMultifurcations",
            "type": "Boolean",
            "description": "Whether or not to turn multifurcations into sequences of bifurcations. (Default true.)",
            "required": false,
            "default": "true"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "Concatenate",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Concatenate",
        "description": "A Function whose elements are the result of concatenating the elements of the input Functions.",
        "generatorType": "function",
        "generatedType": "Concatenate",
        "arguments": [
          {
            "name": "arg",
            "type": "List<Function>",
            "description": "One or more functions to concatenate.",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Interleave",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Interleave",
        "description": "A function produced by interleaving the elements of two or more input functions.",
        "generatorType": "function",
        "generatedType": "Interleave",
        "arguments": [
          {
            "name": "arg",
            "type": "List<Function>",
            "description": "Function to interleave.",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Reverse",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Reverse",
        "description": "A Function whose elements are the elements of the input Function but in reverse order.",
        "generatorType": "function",
        "generatedType": "Reverse",
        "arguments": [
          {
            "name": "arg",
            "type": "Function",
            "description": "Argument to reverse elements of.",
            "required": true
          }
        ]
      },
      {
        "name": "SampleAges",
        "package": "feast",
        "fullyQualifiedName": "feast.function.SampleAges",
        "description": "Function representing ages of sample nodes of tree.",
        "generatorType": "function",
        "generatedType": "SampleAges",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "Tree to extract leaf ages from.",
            "required": true
          }
        ]
      },
      {
        "name": "Scale",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Scale",
        "description": "A Function whose elements are the elements of an input Function scaled by another input Function.",
        "generatorType": "function",
        "generatedType": "Scale",
        "arguments": [
          {
            "name": "function",
            "type": "Function",
            "description": "Function to scale",
            "required": true
          },
          {
            "name": "scaleBy",
            "type": "List<Function>",
            "description": "Amount to scale by",
            "required": false,
            "default": "[]",
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "Sequence",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Sequence",
        "description": "A Function representing a contiguous sequence of integers, e.g. [2,3,4,5].",
        "generatorType": "function",
        "generatedType": "Sequence",
        "arguments": [
          {
            "name": "start",
            "type": "Double",
            "description": "Start value of sequence",
            "required": true
          },
          {
            "name": "stop",
            "type": "Double",
            "description": "Stop value of sequence",
            "required": true
          },
          {
            "name": "length",
            "type": "Integer",
            "description": "Length of sequence",
            "required": true
          }
        ]
      },
      {
        "name": "Slice",
        "package": "feast",
        "fullyQualifiedName": "feast.function.Slice",
        "description": "A Function representing a number of elements of another Function.",
        "generatorType": "function",
        "generatedType": "Slice",
        "arguments": [
          {
            "name": "arg",
            "type": "Function",
            "description": "Argument to extract element from.",
            "required": true
          },
          {
            "name": "index",
            "type": "Integer",
            "description": "Index of first element to extract.",
            "required": true
          },
          {
            "name": "count",
            "type": "Integer",
            "description": "Number of elements to extract.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "by",
            "type": "Integer",
            "description": "Interval between elements (default 1).",
            "required": false,
            "default": "1"
          }
        ]
      },
      {
        "name": "TraitSetAsFunction",
        "package": "feast",
        "fullyQualifiedName": "feast.function.TraitSetAsFunction",
        "description": "All trait sets have at least some (potentially useless) representation as a vector of doubles.  This class just allows you to explicitly treat them as Functions.",
        "generatorType": "function",
        "generatedType": "TraitSetAsFunction",
        "arguments": [
          {
            "name": "traitSet",
            "type": "TraitSet",
            "description": "Trait set to represent as a function.",
            "required": true
          }
        ]
      },
      {
        "name": "UniqueElementCount",
        "package": "feast",
        "fullyQualifiedName": "feast.function.UniqueElementCount",
        "description": "Function representing the number of unique elements of another function.",
        "generatorType": "function",
        "generatedType": "UniqueElementCount",
        "arguments": [
          {
            "name": "arg",
            "type": "Function",
            "description": "Number of unique elements of this parameter will be logged.",
            "required": true
          }
        ]
      },
      {
        "name": "DirichletProcessPrior",
        "package": "feast",
        "fullyQualifiedName": "feast.modelselect.DirichletProcessPrior",
        "description": "A distribution representing the probability of the elements of an input function (parameter) under a Dirichlet process prior with a particular base distribution (baseDistr) and scale paraemter (scaleParameter). In order to use this, you'll need to ensure operators preserve the equivalence of identical elements of function.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "parameter",
            "type": "Function",
            "description": "Array to which to apply DPP.",
            "required": true
          },
          {
            "name": "baseDistr",
            "type": "ParametricDistribution",
            "description": "Base distribution for Dirichlet process",
            "required": true
          },
          {
            "name": "scaleParameter",
            "type": "Function",
            "description": "Scale parameter of DPP.",
            "required": true,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "ModelSelectionParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.modelselect.ModelSelectionParameter",
        "description": "Class of Functions useful for BSSVS-style model selection\/averaging.",
        "generatorType": "function",
        "generatedType": "ModelSelectionParameter",
        "arguments": [
          {
            "name": "parameter",
            "type": "List<Function>",
            "description": "Parameter for the selection pool.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "selectionIndices",
            "type": "IntegerParameter",
            "description": "Integer parameter containing indicies to which each output parameter is mapped.",
            "required": true
          },
          {
            "name": "thisIndex",
            "type": "Integer",
            "description": "Index of output.",
            "required": false,
            "default": "0"
          }
        ]
      },
      {
        "name": "RandomRealParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.parameter.RandomRealParameter",
        "description": "Randomly innitialise a RealParameter by sampling from a ParametricDistribution.",
        "generatorType": "function",
        "generatedType": "RandomRealParameter",
        "arguments": [
          {
            "name": "initial",
            "type": "RealParameter",
            "description": "Parameter to initialize. (If absent, initialise RandomRealParameter itself.)",
            "required": false
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "Distribution from which to draw a random value. Usually the prior ditribution for this parameter.",
            "required": true
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "RealParameterFromFunction",
        "package": "feast",
        "fullyQualifiedName": "feast.parameter.RealParameterFromFunction",
        "description": "A RealParameter initialized from a function.",
        "generatorType": "function",
        "generatedType": "RealParameterFromFunction",
        "arguments": [
          {
            "name": "function",
            "type": "Function",
            "description": "Function used to initialize RealParameter.",
            "required": true
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "TimeParameter",
        "package": "feast",
        "fullyQualifiedName": "feast.parameter.TimeParameter",
        "description": "RealParameter with a constructor that sets initial values based on formatted dates converted to ages relative to the most recent sample on the tree.",
        "generatorType": "function",
        "generatedType": "TimeParameter",
        "arguments": [
          {
            "name": "timeFormat",
            "type": "String",
            "description": "The time format to be parsed, e.g. dd\/M\/yyyy",
            "required": false
          },
          {
            "name": "time",
            "type": "String",
            "description": "One or more (space-delimited) times to be used in initializing parameter",
            "required": true
          },
          {
            "name": "timeEarlier",
            "type": "String",
            "description": "Time to be converted into an upper bound on the parameter value, in format specified by timeFormat",
            "required": false
          },
          {
            "name": "timeLater",
            "type": "String",
            "description": "Time to be converted into an lower bound on the parameter value, in format specified by timeFormat",
            "required": false
          },
          {
            "name": "mostRecentSampleTime",
            "type": "String",
            "description": "Time of the most recent sample, in format specified by timeFormat",
            "required": true
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "CompoundPopulationModel",
        "package": "feast",
        "fullyQualifiedName": "feast.popmodels.CompoundPopulationModel",
        "description": "Population model constructed by piecewise assembly of other population functions.",
        "generatorType": "function",
        "generatedType": "CompoundPopulationModel",
        "arguments": [
          {
            "name": "populationModel",
            "type": "List<PopulationFunction>",
            "description": "Population model segment",
            "required": false,
            "default": "[]"
          },
          {
            "name": "changeTimes",
            "type": "Function",
            "description": "Times of transitions between individual model segments.",
            "required": true
          },
          {
            "name": "makeContinuous",
            "type": "Boolean",
            "description": "Scale population functions to ensure resulting compound function is continuous. (Default false)",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "ExpressionPopulationModel",
        "package": "feast",
        "fullyQualifiedName": "feast.popmodels.ExpressionPopulationModel",
        "description": "A population model where the population size function is given by an expression evaluated at runtime.",
        "generatorType": "function",
        "generatedType": "ExpressionPopulationModel",
        "arguments": [
          {
            "name": "value",
            "type": "String",
            "description": "Expression needed for calculations.",
            "required": true
          },
          {
            "name": "isLog",
            "type": "Boolean",
            "description": "True if expression represents log(P), false if it represents P. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "arg",
            "type": "List<Function>",
            "description": "Parameters\/functions needed for the calculation",
            "required": false,
            "default": "[]"
          },
          {
            "name": "maxTimeToConsider",
            "type": "Integer",
            "description": "Maximum time to consider when numerically inverting intensity integral.",
            "required": false,
            "default": "1000"
          }
        ]
      },
      {
        "name": "ShiftedPopulationModel",
        "package": "feast",
        "fullyQualifiedName": "feast.popmodels.ShiftedPopulationModel",
        "description": "A population model which is time-shifted relative to an input population model.",
        "generatorType": "function",
        "generatedType": "ShiftedPopulationModel",
        "arguments": [
          {
            "name": "populationModel",
            "type": "PopulationFunction",
            "description": "Population model to shift in time",
            "required": true
          },
          {
            "name": "offset",
            "type": "Function",
            "description": "Time offset to use.",
            "required": true
          }
        ]
      },
      {
        "name": "ShuffledAlignment",
        "package": "feast",
        "fullyQualifiedName": "feast.simulation.ShuffledAlignment",
        "description": "A sequence alignment which is a randomly shuffled version of the input alignment.  Can be used for performing date randomization tests.",
        "generatorType": "function",
        "generatedType": "ShuffledAlignment",
        "arguments": [
          {
            "name": "alignment",
            "type": "Alignment",
            "description": "Alignment to be shuffled.",
            "required": true
          },
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "SimulatedAlignment",
        "package": "feast",
        "fullyQualifiedName": "feast.simulation.SimulatedAlignment",
        "description": "A more flexible alignment simulator. Doesn't require pre-specification of number of taxa.",
        "generatorType": "function",
        "generatedType": "SimulatedAlignment",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "Tree down which to simulate sequence evolution.",
            "required": true
          },
          {
            "name": "siteModel",
            "type": "SiteModel",
            "description": "Site model to use in simulation.",
            "required": true
          },
          {
            "name": "sequenceLength",
            "type": "Integer",
            "description": "Length of sequence to simulate.",
            "required": true
          },
          {
            "name": "outputFileName",
            "type": "String",
            "description": "Name of file (if any) simulated alignment should be saved to.",
            "required": false
          },
          {
            "name": "startingSequence",
            "type": "Sequence",
            "description": "Initial sequence to start from.  (Default is random draw from equilibrium distribution.)",
            "required": false
          },
          {
            "name": "startingSequenceAge",
            "type": "Function",
            "description": "When startingSequence is specified, age (relative to the final sample) at which the sequence simulation starts from. (Default is the age of the root of the tree, but use this to make the starting sequence correspond toan earlier time.) Must be greater than the tMRCA of the tree.",
            "required": false
          },
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "CachedDistribution",
        "package": "ORC",
        "fullyQualifiedName": "orc.consoperators.CachedDistribution",
        "description": "Caches parametric distribution for inverscumulative methods.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "Underlying parametric distribution that is cached.",
            "required": true
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "PiecewiseLinearDistribution",
        "package": "ORC",
        "fullyQualifiedName": "orc.consoperators.PiecewiseLinearDistribution",
        "description": "Approximates parametric distribution by piecewise linear approximation.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "Underlying parametric distribution that is approximated.",
            "required": true
          },
          {
            "name": "bins",
            "type": "Integer",
            "description": "number of bins used to approximate the distribution piecewise linearly. (default 100)",
            "required": false,
            "default": "100"
          },
          {
            "name": "limit",
            "type": "Double",
            "description": "fraction of bins at end of distribution to be cut off -- should be between 0 and 1",
            "required": false,
            "default": "0.1"
          },
          {
            "name": "cutOffEnd",
            "type": "Boolean",
            "description": "approximate values below for quantiles close to 0 and 1 with rate at limit\/bins and (1-limit\/bins) respectively.If false, for quantiles below limit\/bins and above (1-limit\/bins) the inverseCumulativeProbability methods of the underlying parametric distribution is called(which is slower, but should not happen very often).",
            "required": false,
            "default": "true"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "DiversificationTurnoverParameterization",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.DiversificationTurnoverParameterization",
        "description": "BEAST2 DiversificationTurnoverParameterization",
        "generatorType": "function",
        "generatedType": "DiversificationTurnoverParameterization",
        "arguments": [
          {
            "name": "origin",
            "type": "RealParameter",
            "description": "The time when the process started",
            "required": true
          },
          {
            "name": "diversificationRate",
            "type": "RealParameter",
            "description": "Net diversification rate. Birth rate - death rate",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "turnover",
            "type": "RealParameter",
            "description": "Turnover. Death rate\/birth rate",
            "required": true
          },
          {
            "name": "samplingProportion",
            "type": "RealParameter",
            "description": "The probability of sampling prior to death. Sampling rate\/(sampling rate + death rate)",
            "required": true
          }
        ]
      },
      {
        "name": "DiversificationTurnoverPsiExpectedNParameterization",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.DiversificationTurnoverPsiExpectedNParameterization",
        "description": "BEAST2 DiversificationTurnoverPsiExpectedNParameterization",
        "generatorType": "function",
        "generatedType": "DiversificationTurnoverPsiExpectedNParameterization",
        "arguments": [
          {
            "name": "expectedN",
            "type": "RealParameter",
            "description": "The expected number of species at the present",
            "required": true
          },
          {
            "name": "diversificationRate",
            "type": "RealParameter",
            "description": "Net diversification rate. Birth rate - death rate",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "turnover",
            "type": "RealParameter",
            "description": "Turnover. Death rate\/birth rate",
            "required": true
          },
          {
            "name": "samplingRate",
            "type": "RealParameter",
            "description": "Sampling rate per individual",
            "required": true,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "ParameterizedSABirthDeathModel",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.ParameterizedSABirthDeathModel",
        "description": "Calculate tree density under Birth Death Sampling Through Time Model for Epidemics that is the BDM where an individual is sampled at a time with a constant rate psi and where an individual becomes noninfectious immediately after the samplingwith a constant probability r",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "parameterization",
            "type": "SABDParameterization",
            "description": "The parameterization to use.",
            "required": true
          },
          {
            "name": "removalProbability",
            "type": "RealParameter",
            "description": "The probability that an individual is removed from the process after the sampling",
            "required": true,
            "constraint": "probability"
          },
          {
            "name": "rho",
            "type": "RealParameter",
            "description": "Probability of an individual to be sampled at present",
            "required": false
          },
          {
            "name": "conditionOnSampling",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on sampling at least one individual",
            "required": false,
            "default": "false"
          },
          {
            "name": "conditionOnRhoSampling",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on sampling at least one individual in present",
            "required": false,
            "default": "false"
          },
          {
            "name": "conditionOnRoot",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on the root height otherwise on the time of origin",
            "required": false,
            "default": "false"
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "ProbabilitySA",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.ProbabilitySA",
        "description": "BEAST2 ProbabilitySA",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "SA",
            "type": "IntegerParameter",
            "description": "A binary parameter that describe the fact that a lineage has no sampled descendants (zero) or it has sampled descendants (one)",
            "required": true
          },
          {
            "name": "time",
            "type": "RealParameter",
            "description": "The time of the lineage",
            "required": true
          },
          {
            "name": "origin",
            "type": "RealParameter",
            "description": "The time when the process started",
            "required": false
          },
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "Birth rate",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "deathRate",
            "type": "RealParameter",
            "description": "Death rate",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "samplingRate",
            "type": "RealParameter",
            "description": "Sampling rate per individual",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "diversificationRate",
            "type": "RealParameter",
            "description": "Net diversification rate. Birth rate - death rate",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "turnover",
            "type": "RealParameter",
            "description": "Turnover. Death rate\/birth rate",
            "required": false
          },
          {
            "name": "samplingProportion",
            "type": "RealParameter",
            "description": "The probability of sampling prior to death. Sampling rate\/(sampling rate + death rate)",
            "required": false
          },
          {
            "name": "removalProbability",
            "type": "RealParameter",
            "description": "The probability that an individual is removed from the process after the sampling",
            "required": true,
            "constraint": "probability"
          },
          {
            "name": "rho",
            "type": "RealParameter",
            "description": "Probability of an individual to be sampled at present",
            "required": false
          },
          {
            "name": "conditionOnSampling",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on sampling at least one individual",
            "required": false,
            "default": "false"
          },
          {
            "name": "conditionOnRhoSampling",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on sampling at least one individual in present",
            "required": false,
            "default": "false"
          },
          {
            "name": "conditionOnRoot",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on the root height otherwise on the time of origin",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "RateParameterization",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.RateParameterization",
        "description": "BEAST2 RateParameterization",
        "generatorType": "function",
        "generatedType": "RateParameterization",
        "arguments": [
          {
            "name": "origin",
            "type": "RealParameter",
            "description": "The time when the process started",
            "required": true
          },
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "Birth rate",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "deathRate",
            "type": "RealParameter",
            "description": "Death rate",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "samplingRate",
            "type": "RealParameter",
            "description": "Sampling rate per individual",
            "required": true,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "SABirthDeathModel",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.speciation.SABirthDeathModel",
        "description": "Calculate tree density under Birth Death Sampling Through Time Model for Epidemics that is the BDM where an individual is sampled at a time with a constant rate psi and where an individual becomes noninfectious immediately after the samplingwith a constant probability r",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "treeWOffset",
            "type": "TreeWOffset",
            "description": "Optional fully extinct tree",
            "required": false
          },
          {
            "name": "origin",
            "type": "RealParameter",
            "description": "The time when the process started",
            "required": false
          },
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "Birth rate",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "deathRate",
            "type": "Function",
            "description": "Death rate",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "samplingRate",
            "type": "RealParameter",
            "description": "Sampling rate per individual",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "expectedN",
            "type": "RealParameter",
            "description": "The expected-N-at-present parameterisation of T",
            "required": false
          },
          {
            "name": "diversificationRate",
            "type": "RealParameter",
            "description": "Net diversification rate. Birth rate - death rate",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "turnover",
            "type": "Function",
            "description": "Turnover. Death rate\/birth rate",
            "required": false
          },
          {
            "name": "samplingProportion",
            "type": "RealParameter",
            "description": "The probability of sampling prior to death. Sampling rate\/(sampling rate + death rate)",
            "required": false
          },
          {
            "name": "removalProbability",
            "type": "RealParameter",
            "description": "The probability that an individual is removed from the process after the sampling",
            "required": true,
            "constraint": "probability"
          },
          {
            "name": "rho",
            "type": "RealParameter",
            "description": "Probability of an individual to be sampled at present",
            "required": false
          },
          {
            "name": "conditionOnSampling",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on sampling at least one individual if condition on origin or at least one individual on both sides of the root if condition on root",
            "required": false,
            "default": "false"
          },
          {
            "name": "conditionOnRhoSampling",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on sampling at least one individual in present if condition on origin or at lease one extant individual on both sides of the root if condition on root",
            "required": false,
            "default": "false"
          },
          {
            "name": "conditionOnRoot",
            "type": "Boolean",
            "description": "the tree likelihood is conditioned on the root height otherwise on the time of origin",
            "required": false,
            "default": "false"
          },
          {
            "name": "taxon",
            "type": "Taxon",
            "description": "a name of the taxon for which to calculate the prior probability ofbeing sampled ancestor under the model",
            "required": false
          },
          {
            "name": "SAtaxon",
            "type": "IntegerParameter",
            "description": "A binary parameter is equal to zero if the taxon is not a sampled ancestor (that is, it does not have sampled descendants) and to one if it is a sampled ancestor (that is, it has sampled descendants)",
            "required": false
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "AncestryConstraint",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.AncestryConstraint",
        "description": "Method to force extinct samples to be ancestral to a set of taxa in the tree. This is meant to be used for sensitivity analyses and testing purposes only. ",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "taxonsetIn",
            "type": "TaxonSet",
            "description": "set of taxa inside the clade, in-taxa.",
            "required": true
          },
          {
            "name": "taxonsetOut",
            "type": "TaxonSet",
            "description": "set of taxa outside the clade. If it is not specified then the in-taxa are considered to be monophyletic.",
            "required": false
          },
          {
            "name": "directAncestor",
            "type": "Taxon",
            "description": "direct ancestor of the taxonsetIn clade. ",
            "required": false
          },
          {
            "name": "strict",
            "type": "Boolean",
            "description": "enforce ancestry strictly (default), or allow breaking it with low probablity?",
            "required": false,
            "default": "true"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa for which prior information is available",
            "required": false
          },
          {
            "name": "monophyletic",
            "type": "Boolean",
            "description": "whether the taxon set is monophyletic (forms a clade without other taxa) or nor. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior over MRCA time, e.g. normal, beta, gamma. If not specified, monophyletic must be true",
            "required": false
          },
          {
            "name": "tipsonly",
            "type": "Boolean",
            "description": "flag to indicate tip dates are to be used instead of the MRCA node. If set to true, the prior is applied to the height of all tips in the taxonset and the monophyletic flag is ignored. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "useOriginate",
            "type": "Boolean",
            "description": "Use parent of clade instead of clade. Cannot be used with tipsonly, or on the root.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "CladeConstraint",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.CladeConstraint",
        "description": "BEAST2 CladeConstraint",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree to apply the constraint on",
            "required": true
          },
          {
            "name": "taxonsetIn",
            "type": "TaxonSet",
            "description": "set of taxa inside the clade, in-taxa.",
            "required": true
          },
          {
            "name": "taxonsetOut",
            "type": "TaxonSet",
            "description": "set of taxa outside the clade. If it is not specified then the in-taxa are considered to be monophyletic.",
            "required": false
          },
          {
            "name": "stronglyMonophyletic",
            "type": "Boolean",
            "description": "is true if the most recent common ancestor of the clade is not a sampled node andtherefore has two children which both have extant descendants. Default is false.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "SamplingDate",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.SamplingDate",
        "description": "BEAST2 SamplingDate",
        "generatorType": "function",
        "generatedType": "SamplingDate",
        "arguments": [
          {
            "name": "taxon",
            "type": "Taxon",
            "description": "Name of the taxon for which the sampling date distribution is specified.",
            "required": true
          },
          {
            "name": "upper",
            "type": "String",
            "description": "Upper bound for the taxon sampling date",
            "required": false
          },
          {
            "name": "lower",
            "type": "String",
            "description": "Lower bound for the taxon sampling date",
            "required": false
          }
        ]
      },
      {
        "name": "TreeWOffset",
        "package": "SA",
        "fullyQualifiedName": "sa.evolution.tree.TreeWOffset",
        "description": "BEAST2 TreeWOffset",
        "generatorType": "function",
        "generatedType": "TreeWOffset",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree topology",
            "required": true
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "Starting offset to present, default 0",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "DegenerateBeta",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.DegenerateBeta",
        "description": "BEAST2 DegenerateBeta",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "RealParameter",
            "description": "first shape parameter, defaults to 1",
            "required": true
          },
          {
            "name": "beta",
            "type": "RealParameter",
            "description": "the other shape parameter, defaults to 1",
            "required": true
          },
          {
            "name": "mass",
            "type": "Double",
            "description": "probability mass to put on a point",
            "required": false,
            "default": "0.5"
          },
          {
            "name": "point",
            "type": "Double",
            "description": "the point on which the probability mass is put",
            "required": false,
            "default": "1.0"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "DegenerateUniform",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.DegenerateUniform",
        "description": "BEAST2 DegenerateUniform",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "lower",
            "type": "Double",
            "description": "lower bound on the interval, defaul 0",
            "required": false,
            "default": "0.0"
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "lower bound on the interval, defaul 1",
            "required": false,
            "default": "1.0"
          },
          {
            "name": "mass",
            "type": "Double",
            "description": "probability mass to put on a point",
            "required": false,
            "default": "0.5"
          },
          {
            "name": "point",
            "type": "Double",
            "description": "the point on which the probability mass is put",
            "required": false,
            "default": "1.0"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "SAMRCAPrior",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.SAMRCAPrior",
        "description": "Behaves the same as a MRCAPrior, but allows BEAUti to know how to add the correct operators for tips sampling",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa for which prior information is available",
            "required": false
          },
          {
            "name": "monophyletic",
            "type": "Boolean",
            "description": "whether the taxon set is monophyletic (forms a clade without other taxa) or nor. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior over MRCA time, e.g. normal, beta, gamma. If not specified, monophyletic must be true",
            "required": false
          },
          {
            "name": "tipsonly",
            "type": "Boolean",
            "description": "flag to indicate tip dates are to be used instead of the MRCA node. If set to true, the prior is applied to the height of all tips in the taxonset and the monophyletic flag is ignored. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "useOriginate",
            "type": "Boolean",
            "description": "Use parent of clade instead of clade. Cannot be used with tipsonly, or on the root.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "SpecialMRCAPrior",
        "package": "SA",
        "fullyQualifiedName": "sa.math.distributions.SpecialMRCAPrior",
        "description": "BEAST2 SpecialMRCAPrior",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "taxonsetOut",
            "type": "TaxonSet",
            "description": "set of taxa which are outside of the clade",
            "required": false
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa for which prior information is available",
            "required": false
          },
          {
            "name": "monophyletic",
            "type": "Boolean",
            "description": "whether the taxon set is monophyletic (forms a clade without other taxa) or nor. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior over MRCA time, e.g. normal, beta, gamma. If not specified, monophyletic must be true",
            "required": false
          },
          {
            "name": "tipsonly",
            "type": "Boolean",
            "description": "flag to indicate tip dates are to be used instead of the MRCA node. If set to true, the prior is applied to the height of all tips in the taxonset and the monophyletic flag is ignored. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "useOriginate",
            "type": "Boolean",
            "description": "Use parent of clade instead of clade. Cannot be used with tipsonly, or on the root.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "ClusterZBSATree",
        "package": "SA",
        "fullyQualifiedName": "sa.util.ClusterZBSATree",
        "description": "Create initial beast.tree by hierarchical clustering, either through one of the classic link methods or by neighbor joining. The following link methods are supported: <br\/>o single link, <br\/>o complete link, <br\/>o UPGMA=average link, <br\/>o mean link, <br\/>o centroid, <br\/>o Ward and <br\/>o adjusted complete link <br\/>o neighborjoining <br\/>o neighborjoining2 - corrects tree for tip data, unlike plain neighborjoining",
        "generatorType": "function",
        "generatedType": "ClusterZBSATree",
        "arguments": [
          {
            "name": "clusterType",
            "type": "String",
            "description": "type of clustering algorithm used for generating initial beast.tree. Should be one of [single, average, complete, upgma, mean, centroid, ward, adjcomplete, neighborjoining, neighborjoining2] (default average)",
            "required": false,
            "default": "average"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "alignment data used for calculating distances for clustering",
            "required": false
          },
          {
            "name": "distance",
            "type": "Distance",
            "description": "method for calculating distance between two sequences (default Jukes Cantor)",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "ZeroBranchSATreeParser",
        "package": "SA",
        "fullyQualifiedName": "sa.util.ZeroBranchSATreeParser",
        "description": "Create beast.tree by parsing from a specification of a beast.tree (which is a fake SA tree) in Newick format (includes parsing of any meta data in the Newick string).",
        "generatorType": "function",
        "generatedType": "ZeroBranchSATreeParser",
        "arguments": [
          {
            "name": "IsLabelledNewick",
            "type": "Boolean",
            "description": "Is the newick tree labelled? Default=false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "Specifies the list of taxa represented by leaves in the beast.tree",
            "required": false
          },
          {
            "name": "newick",
            "type": "String",
            "description": "initial beast.tree represented in newick format",
            "required": false
          },
          {
            "name": "offset",
            "type": "Integer",
            "description": "offset if numbers are used for taxa (offset=the lowest taxa number) default=1",
            "required": false,
            "default": "1"
          },
          {
            "name": "threshold",
            "type": "Double",
            "description": "threshold under which node heights (derived from lengths) are set to zero. Default=0.",
            "required": false,
            "default": "0.0"
          },
          {
            "name": "singlechild",
            "type": "Boolean",
            "description": "flag to indicate that single child nodes are allowed. Default=true.",
            "required": false,
            "default": "true"
          },
          {
            "name": "scale",
            "type": "Double",
            "description": "scale used to multiply internal node heights during parsing.Useful for importing starting from external programs, for instance, RaxML tree rooted using Path-o-gen.",
            "required": false,
            "default": "1.0",
            "constraint": "positive"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "DataNode",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.DataNode",
        "description": "Represents some piece of data for which a likelihood can be calculated",
        "generatorType": "function",
        "generatedType": "DataNode",
        "arguments": []
      },
      {
        "name": "FilteredValuable",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.FilteredValuable",
        "description": "selects values from a parameter, for instance all even indexed entries",
        "generatorType": "function",
        "generatedType": "FilteredValuable",
        "arguments": [
          {
            "name": "parameter",
            "type": "Function",
            "description": "the parameter to select values from",
            "required": true
          },
          {
            "name": "range",
            "type": "String",
            "description": "specifies list of indices First site is 1.Filter specs are comma separated, either a range [from]-[to] or iteration [from]:[to]:[step]; 1-100 defines a range, 1-100\u0003 or 1:100:3 defines every third in range 1-100, 1::3,2::3 removes every third site. negative values count from the last: -1 indicate the last element, -2 the one but last. Default for range [1]-[last site], default for iterator [1]:[last site]:[1]",
            "required": true
          }
        ]
      },
      {
        "name": "Likelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.Likelihood",
        "description": "Represents one of more likelihoods which represent the probability of some data (e.g. a sequence alignment), possibly conditioned on one or more DataNodes (e.g. a Tree or set of Parameters). The class checks that Data has not defined more than one likelihood.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "distribution",
            "type": "List<Distribution>",
            "description": "individual probability distributions, e.g. the likelihood and prior making up a posterior",
            "required": false,
            "default": "[]"
          },
          {
            "name": "useThreads",
            "type": "Boolean",
            "description": "calculated the distributions in parallel using threads (default false)",
            "required": false,
            "default": "false"
          },
          {
            "name": "threads",
            "type": "Integer",
            "description": "maximum number of threads to use, if less than 1 the number of threads in BeastMCMC is used (default -1)",
            "required": false,
            "default": "-1"
          },
          {
            "name": "ignore",
            "type": "Boolean",
            "description": "ignore all distributions and return 1 as distribution (default false)",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "CompoundRealParameter",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.parameter.CompoundRealParameter",
        "description": "Parmeter consisting of 2 or more RealParameters but behaving like a single RealParameter",
        "generatorType": "function",
        "generatedType": "CompoundRealParameter",
        "arguments": [
          {
            "name": "parameter",
            "type": "List<RealParameter>",
            "description": "parameters making up the compound parameter",
            "required": true,
            "default": "[]"
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "NormalisedRealParameter",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.parameter.NormalisedRealParameter",
        "description": "Constant value that acts as immutable RealParameter where values are normalised",
        "generatorType": "function",
        "generatedType": "NormalisedRealParameter",
        "arguments": [
          {
            "name": "x",
            "type": "List<Function>",
            "description": "values makeng up the parameter",
            "required": true,
            "default": "[]"
          },
          {
            "name": "logtransform",
            "type": "Boolean",
            "description": "log-transform values before normalising",
            "required": false,
            "default": "false"
          },
          {
            "name": "meanZeroVarOne",
            "type": "Boolean",
            "description": "transform values so that the mean=0 and variance=1. If false, normalise so that sum=1",
            "required": false,
            "default": "false"
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "Posterior",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.Posterior",
        "description": "Posterior, consisting of a prior and a likehood",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "prior",
            "type": "Object",
            "description": "prior distribution over the state",
            "required": true
          },
          {
            "name": "likelihood",
            "type": "Likelihood",
            "description": "Likelihood distribution over the data",
            "required": true
          }
        ]
      },
      {
        "name": "LoggableSum",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.util.LoggableSum",
        "description": "Logs the sum of anything that is Valuable",
        "generatorType": "function",
        "generatedType": "LoggableSum",
        "arguments": [
          {
            "name": "value",
            "type": "Function",
            "description": "Valuable Plugin that needs logging the sum of",
            "required": true
          }
        ]
      },
      {
        "name": "ParameterConstrainer",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.util.ParameterConstrainer",
        "description": "Class to constrain a multi-dimensional parameter to have a certain value (like 0) at a certain time range",
        "generatorType": "function",
        "generatedType": "ParameterConstrainer",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "the phylogenetic tree to provide tree height",
            "required": true
          },
          {
            "name": "orig_root",
            "type": "RealParameter",
            "description": "The origin of infection x0",
            "required": true
          },
          {
            "name": "constraintValue",
            "type": "Double",
            "description": "The value to be used from startTime to time endTime",
            "required": true
          },
          {
            "name": "startTime",
            "type": "Double",
            "description": "The startTime from when to constrain on, (in forward time)",
            "required": true
          },
          {
            "name": "endTime",
            "type": "Double",
            "description": "The endTime until when to constrain, (in forward time)",
            "required": true
          },
          {
            "name": "constrainedParameter",
            "type": "RealParameter",
            "description": "parameter to be constrained",
            "required": true
          },
          {
            "name": "baseParameter",
            "type": "RealParameter",
            "description": "the unconstrained base parameter",
            "required": true
          }
        ]
      },
      {
        "name": "Slice",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.core.util.Slice",
        "description": "A Function representing a number of elements of another Function.",
        "generatorType": "function",
        "generatedType": "Slice",
        "arguments": [
          {
            "name": "arg",
            "type": "Function",
            "description": "Argument to extract element from.",
            "required": true
          },
          {
            "name": "index",
            "type": "Integer",
            "description": "Index of first element to extract.",
            "required": true
          },
          {
            "name": "count",
            "type": "Integer",
            "description": "Number of elements to extract.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          }
        ]
      },
      {
        "name": "PrunedAlignment",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.alignment.PrunedAlignment",
        "description": "Sub-alignment generated by pruning some taxa and\/or some sites. Can automatically detect taxa with non-informative data (all sites are ambiguous).",
        "generatorType": "function",
        "generatedType": "PrunedAlignment",
        "arguments": [
          {
            "name": "source",
            "type": "Alignment",
            "description": "alignment to prune from",
            "required": true
          },
          {
            "name": "prunedTaxa",
            "type": "TaxonSet",
            "description": "taxa to prune (defaults to all non-informative taxa, i.e. data is all '???')",
            "required": false
          },
          {
            "name": "sites",
            "type": "List<Integer>",
            "description": "sites to retain (default all).",
            "required": false,
            "default": "[]"
          },
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "PrunedRelaxedClockModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.branchratemodel.PrunedRelaxedClockModel",
        "description": "Tree containing a subset of nodes from another tree",
        "generatorType": "function",
        "generatedType": "PrunedRelaxedClockModel",
        "arguments": [
          {
            "name": "rates",
            "type": "UCRelaxedClockModel",
            "description": "clock model used on original tree",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "tree",
            "type": "PrunedTree",
            "description": "source tree to be pruned",
            "required": true
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "ExperimentalTreeLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.likelihood.ExperimentalTreeLikelihood",
        "description": "Calculates the likelihood of sequence data on a beast.tree given a site and substitution model using a variant of the 'peeling algorithm'. For details, seeFelsenstein, Joseph (1981). Evolutionary trees from DNA sequences: a maximum likelihood approach. J Mol Evol 17 (6): 368-376.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "data",
            "type": "Alignment",
            "description": "sequence data for the beast.tree",
            "required": true
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "phylogenetic beast.tree with sequence data in the leafs",
            "required": true
          },
          {
            "name": "siteModel",
            "type": "SiteModelInterface.Base",
            "description": "site model for leafs in the beast.tree",
            "required": true
          },
          {
            "name": "branchRateModel",
            "type": "BranchRateModel.Base",
            "description": "A model describing the rates on the branches of the beast.tree.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "useAmbiguities",
            "type": "Boolean",
            "description": "flag to indicate leafs that sites containing ambigue states should be handled instead of ignored (the default)",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "SupertreeLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.likelihood.SupertreeLikelihood",
        "description": "A supertree likelihood for a set of subtrees.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "data",
            "type": "List<Tree>",
            "description": "list of sub trees",
            "required": true,
            "default": "[]"
          },
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "the super tree to be estimated.",
            "required": true
          },
          {
            "name": "beta",
            "type": "Double",
            "description": "the beta function defining the rate of probability fall off with tree distance.",
            "required": true
          },
          {
            "name": "treeMetric",
            "type": "TreeMetric",
            "description": "the tree metric to use for the tree distances in the likelihood function.",
            "required": true
          }
        ]
      },
      {
        "name": "TraitedTreeLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.likelihood.TraitedTreeLikelihood",
        "description": "Performs peeling algorithm over a tree using a trait as values for tips instead of a sequence",
        "generatorType": "distribution",
        "generatedType": "Alignment",
        "arguments": [
          {
            "name": "dataType",
            "type": "DataType.Base",
            "description": "data type of the trait",
            "required": true
          },
          {
            "name": "traitSet",
            "type": "TraitSet",
            "description": "set of traits associated with tips",
            "required": true
          },
          {
            "name": "useAmbiguities",
            "type": "Boolean",
            "description": "flag to indicate that sites containing ambiguous states should be handled instead of ignored (the default)",
            "required": false,
            "default": "false"
          },
          {
            "name": "useTipLikelihoods",
            "type": "Boolean",
            "description": "flag to indicate that partial likelihoods are provided at the tips",
            "required": false,
            "default": "false"
          },
          {
            "name": "implementation",
            "type": "String",
            "description": "name of class that implements this treelikelihood potentially more efficiently. This class will be tried first, with the TreeLikelihood as fallback implementation. When multi-threading, multiple objects can be created.",
            "required": false,
            "default": "beast.evolution.likelihood.BeagleTreeLikelihood"
          },
          {
            "name": "scaling",
            "type": "TreeLikelihood.Scaling",
            "description": "type of scaling to use, one of [none, always, _default]. If not specified, the -beagle_scaling flag is used.",
            "required": false,
            "default": "_default"
          },
          {
            "name": "rootFrequencies",
            "type": "Frequencies",
            "description": "prior state frequencies at root, optional",
            "required": false
          },
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "phylogenetic beast.tree with sequence data in the leafs",
            "required": true
          },
          {
            "name": "siteModel",
            "type": "SiteModelInterface",
            "description": "site model for leafs in the beast.tree",
            "required": true
          },
          {
            "name": "branchRateModel",
            "type": "BranchRateModel.Base",
            "description": "A model describing the rates on the branches of the beast.tree.",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "RandomLocalYuleModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.speciation.RandomLocalYuleModel",
        "description": "A speciation model of a Yule process whose rate of birth changes at different points in the tree.",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "birthRates",
            "type": "RealParameter",
            "description": "birth rates parameter, lambda in birth\/death model",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "indicators",
            "type": "BooleanParameter",
            "description": "the indicators associated with nodes in the tree for sampling of individual rate of birth changes among branches.",
            "required": true
          },
          {
            "name": "meanRate",
            "type": "RealParameter",
            "description": "an parameter to set the mean rate of birth across the whole tree",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "ratesAreMultipliers",
            "type": "Boolean",
            "description": "birth rates are multipliers (default false)",
            "required": false,
            "default": "false",
            "constraint": "positive"
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "CladeSubstitutionModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.CladeSubstitutionModel",
        "description": "Substitution model dependent on clades. For each clade a substitution model is specified. For nodes that do not fit in a clade a default substitution model is used.",
        "generatorType": "function",
        "generatedType": "CladeSubstitutionModel",
        "arguments": [
          {
            "name": "defaultModel",
            "type": "SubstitutionModel",
            "description": "Default substitution model, that is, the model that applies when none of the other do",
            "required": true
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree for which to produce substitution models",
            "required": true
          },
          {
            "name": "cladeModel",
            "type": "List<SubstitutionModel>",
            "description": "substitution model for each of the clades specified",
            "required": false,
            "default": "[]"
          },
          {
            "name": "clades",
            "type": "List<TaxonSet>",
            "description": "set of taxa forming a clade and any branch in the clade will get a clade substitution model",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "set taxa to choose from",
            "required": true
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "EpochSubstitutionModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.EpochSubstitutionModel",
        "description": "A substitution model that can change at various threshold dates.",
        "generatorType": "function",
        "generatedType": "EpochSubstitutionModel",
        "arguments": [
          {
            "name": "model",
            "type": "List<SubstitutionModel>",
            "description": "substitution models that apply for certain time intervals",
            "required": false,
            "default": "[]"
          },
          {
            "name": "epochDates",
            "type": "RealParameter",
            "description": "list of threshold dates. The list indicates the dates at which substitution models are switched.",
            "required": true
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "GeneralLazySubstitutionModel",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.GeneralLazySubstitutionModel",
        "description": "Uses a super-relaxed clock model. Note, this should only be used with strict clock models.",
        "generatorType": "function",
        "generatedType": "GeneralLazySubstitutionModel",
        "arguments": [
          {
            "name": "mode",
            "type": "GeneralLazySubstitutionModel.RelaxationMode",
            "description": "form of the  prior distribution used for relaxation This can be [exponential, gamma, inverse_gamma] (default 'exponential')",
            "required": false,
            "default": "exponential"
          },
          {
            "name": "theta",
            "type": "RealParameter",
            "description": "shape parameter, ignored with exponential prior",
            "required": false
          },
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "LazyHKY",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.substitutionmodel.LazyHKY",
        "description": "Lazy version of HKY85 substitution model of nucleotide evolution.",
        "generatorType": "function",
        "generatedType": "LazyHKY",
        "arguments": [
          {
            "name": "mode",
            "type": "LazyHKY.RelaxationMode",
            "description": "form of the  prior distribution used for relaxation This can be [exponential, gamma, inverse_gamma] (default 'exponential')",
            "required": false,
            "default": "exponential"
          },
          {
            "name": "theta",
            "type": "RealParameter",
            "description": "shape parameter, ignored with exponential prior",
            "required": false
          },
          {
            "name": "kappa",
            "type": "Function",
            "description": "kappa parameter in HKY model",
            "required": true
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "Taxon",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.taxonomy.Taxon",
        "description": "For identifying a single taxon, modified to be comparable",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Taxon"
      },
      {
        "name": "CauchyPlusConstant",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.coalescent.CauchyPlusConstant",
        "description": "Population model of the form A\/(B*(t-t0)^2 + 1) + C.",
        "generatorType": "function",
        "generatedType": "CauchyPlusConstant",
        "arguments": [
          {
            "name": "A",
            "type": "RealParameter",
            "description": "Magnitude of Cauchy distribution.",
            "required": true
          },
          {
            "name": "B",
            "type": "RealParameter",
            "description": "Width of Cauchy distribution.",
            "required": true
          },
          {
            "name": "t0",
            "type": "RealParameter",
            "description": "Centre of Cauchy distribution.",
            "required": true
          },
          {
            "name": "C",
            "type": "RealParameter",
            "description": "Constant population offset value.",
            "required": true
          }
        ]
      },
      {
        "name": "ExponentialGrowthPlusConstant",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.coalescent.ExponentialGrowthPlusConstant",
        "description": "Population model of the form A*exp(-B*t) + C",
        "generatorType": "function",
        "generatedType": "ExponentialGrowthPlusConstant",
        "arguments": [
          {
            "name": "A",
            "type": "RealParameter",
            "description": "Initial population size for model.",
            "required": true
          },
          {
            "name": "B",
            "type": "RealParameter",
            "description": "Exponential growth rate of population size.",
            "required": true
          },
          {
            "name": "C",
            "type": "RealParameter",
            "description": "Constant population size offset.",
            "required": true
          }
        ]
      },
      {
        "name": "StructuredCoalescentTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.coalescent.StructuredCoalescentTree",
        "description": "A tree generated randomly from the structured coalescent process, with the given population sizes, migration rates and per-deme sample sizes.",
        "generatorType": "function",
        "generatedType": "StructuredCoalescentTree",
        "arguments": [
          {
            "name": "popSizesMigrationRates",
            "type": "RealParameter",
            "description": "A matrix of migration rates and population sizes. Population sizes occupy the diagonal and migration rates occupy the off-diagonals",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "sampleSizes",
            "type": "IntegerParameter",
            "description": "The sample sizes for each population",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "ConstrainedClusterTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.ConstrainedClusterTree",
        "description": "Create initial beast.tree by hierarchical clustering, either through one of the classic link methods or by neighbor joining. The following link methods are supported: <br\/>o single link, <br\/>o complete link, <br\/>o UPGMA=average link, <br\/>o mean link, <br\/>o centroid, <br\/>o Ward and <br\/>o adjusted complete link <br\/>o neighborjoining <br\/>o neighborjoining2 - corrects tree for tip data, unlike plain neighborjoining",
        "generatorType": "function",
        "generatedType": "ConstrainedClusterTree",
        "arguments": [
          {
            "name": "constraint",
            "type": "List<MRCAPrior>",
            "description": "specifies (monophyletic or height distribution) constraints on internal nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "constraints",
            "type": "MultiMonophyleticConstraint",
            "description": "all constraints as encoded by one unresolved tree.",
            "required": false
          },
          {
            "name": "minBranchLength",
            "type": "Double",
            "description": "lower bound on lengths used for creating branches",
            "required": false,
            "default": "1.0E-10"
          },
          {
            "name": "clusterType",
            "type": "ConstrainedClusterTree.Type",
            "description": "type of clustering algorithm used for generating initial beast.tree. Should be one of [Lbeastlabs.evolution.tree.ConstrainedClusterTree$Type;@6970140a (default average)",
            "required": false,
            "default": "average"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "alignment data used for calculating distances for clustering",
            "required": false
          },
          {
            "name": "distance",
            "type": "Distance",
            "description": "method for calculating distance between two sequences (default Jukes Cantor)",
            "required": false
          },
          {
            "name": "clock.rate",
            "type": "RealParameter",
            "description": "the clock rate parameter, used to divide all divergence times by, to convert from substitutions to times. (default 1.0)",
            "required": false,
            "default": "null[1 1] (-Infinity,Infinity): 1.0 ",
            "constraint": "positive"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "ConstrainedRandomTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.ConstrainedRandomTree",
        "description": "Random tree with constraints specified by one tree, just like multiple monophyly.",
        "generatorType": "function",
        "generatedType": "ConstrainedRandomTree",
        "arguments": [
          {
            "name": "constraints",
            "type": "MultiMonophyleticConstraint",
            "description": "all constraints as encoded by one unresolved tree.",
            "required": true
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "set of taxa to initialise tree specified by alignment",
            "required": false
          },
          {
            "name": "populationModel",
            "type": "PopulationFunction",
            "description": "population function for generating coalescent???",
            "required": true
          },
          {
            "name": "constraint",
            "type": "List<MRCAPrior>",
            "description": "specifies (monophyletic or height distribution) constraints on internal nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "rootHeight",
            "type": "Double",
            "description": "If specified the tree will be scaled to match the root height, if constraints allow this",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "InitParamFromTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.InitParamFromTree",
        "description": "Sets values of a parameter from metadata values associated with a newick tree",
        "generatorType": "function",
        "generatedType": "InitParamFromTree",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree containing some meta data",
            "required": true
          },
          {
            "name": "initial",
            "type": "RealParameter",
            "description": "parameter to be initialised",
            "required": true
          },
          {
            "name": "pattern",
            "type": "String",
            "description": "name of the metadata item to be parsed",
            "required": true
          }
        ]
      },
      {
        "name": "MonophyleticConstraint",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.MonophyleticConstraint",
        "description": "Enforces groups of taxa to be monophyletic -- have a common mrca that no other taxa have. This can be used as part of the prior. Multiple monophyletic constraints can be handled by adding one set per constraing.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree to apply the constraint on",
            "required": true
          },
          {
            "name": "set",
            "type": "List<TaxonSet>",
            "description": "set taxa that should be monophyletic",
            "required": true,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "set taxa to choose from",
            "required": true
          }
        ]
      },
      {
        "name": "PrunedTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.PrunedTree",
        "description": "The binary tree generated by pruning a fixed subset of taxa from a source binary tree.",
        "generatorType": "function",
        "generatedType": "PrunedTree",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "source tree to filter\/prune.",
            "required": false
          },
          {
            "name": "alignment",
            "type": "Alignment",
            "description": "take taxa of pruned tree from alignment",
            "required": false
          },
          {
            "name": "quickshortcut",
            "type": "Boolean",
            "description": "Detect pruned tree change in two stages.the first stage requires that all tree operators mark all changed clades (markclades=true in tree operator).",
            "required": false,
            "default": "false"
          },
          {
            "name": "assert",
            "type": "Boolean",
            "description": "perform expensive consistency checks (but only with -ea)",
            "required": false,
            "default": "false"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "RNNIMetric",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.RNNIMetric",
        "description": "Ranked Nearest Neighbour Interchange metric on trees",
        "generatorType": "function",
        "generatedType": "RNNIMetric",
        "arguments": [
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "taxonset of the trees",
            "required": true
          },
          {
            "name": "recursive",
            "type": "Boolean",
            "description": "whether to recurse down the taxon set and take only 'taxon' objects",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "RobinsonsFouldMetric",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.RobinsonsFouldMetric",
        "description": "Robinson-Fould based tree metric",
        "generatorType": "function",
        "generatedType": "RobinsonsFouldMetric",
        "arguments": [
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "taxonset of the trees",
            "required": true
          },
          {
            "name": "recursive",
            "type": "Boolean",
            "description": "whether to recurse down the taxon set and take only 'taxon' objects",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "SimpleConstrainedRandomTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.SimpleConstrainedRandomTree",
        "description": "Random tree with constraints specified by one tree, just like multiple monophyly.",
        "generatorType": "function",
        "generatedType": "SimpleConstrainedRandomTree",
        "arguments": [
          {
            "name": "constraints",
            "type": "List<MultiMonophyleticConstraint>",
            "description": "all constraints as encoded by one unresolved tree.",
            "required": true,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "set of taxa to initialise tree specified by alignment",
            "required": false
          },
          {
            "name": "constraint",
            "type": "List<MRCAPrior>",
            "description": "specifies (monophyletic or height distribution) constraints on internal nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "rootHeight",
            "type": "Double",
            "description": "If specified the tree will be scaled to match the root height, if constraints allow this",
            "required": false
          },
          {
            "name": "branchMean",
            "type": "Double",
            "description": "Branches will be exponentially distributed with this mean (bounds permitting).",
            "required": false,
            "default": "-1.0"
          },
          {
            "name": "limitCalibrations",
            "type": "Double",
            "description": "Initialize node height to be in the center of its calibration. For example, a value of 0.9 will restrict the height to be in the [5%,95%] percentile range. 1 means takes the full range.",
            "required": false,
            "default": "0.95"
          },
          {
            "name": "weights",
            "type": "DistanceProvider",
            "description": "if provided, used to inform sampling distribution such that nodes that are closer have a higher chance of forming a clade",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "SimplePrunedTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.SimplePrunedTree",
        "description": "The binary tree generated by pruning a fixed subset of taxa from a source binary tree. Supposed to be more robust but less efficient than PrunedTreeand not suitable for PrunedRelaxedClocks.",
        "generatorType": "function",
        "generatedType": "SimplePrunedTree",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "source tree to filter\/prune.",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "SimpleRandomTree",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.evolution.tree.SimpleRandomTree",
        "description": "This class provides the basic engine for coalescent simulation of a given demographic model over a given time period. ",
        "generatorType": "function",
        "generatedType": "SimpleRandomTree",
        "arguments": [
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "set of taxa to initialise tree specified by alignment",
            "required": false
          },
          {
            "name": "constraint",
            "type": "List<MRCAPrior>",
            "description": "specifies (monophyletic or height distribution) constraints on internal nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "rootHeight",
            "type": "Double",
            "description": "If specified the tree will be scaled to match the root height, if constraints allow this",
            "required": false
          },
          {
            "name": "branchMean",
            "type": "Double",
            "description": "Branches will be exponentially distributed with this mean (bounds permitting).",
            "required": false,
            "default": "-1.0"
          },
          {
            "name": "limitCalibrations",
            "type": "Double",
            "description": "Initialize node height to be in the center of its calibration. For example, a value of 0.9 will restrict the height to be in the [5%,95%] percentile range. 1 means takes the full range.",
            "required": false,
            "default": "0.95"
          },
          {
            "name": "weights",
            "type": "DistanceProvider",
            "description": "if provided, used to inform sampling distribution such that nodes that are closer have a higher chance of forming a clade",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "BernoulliDistribution",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.BernoulliDistribution",
        "description": "Bernoulli distribution, used as prior or likelihood.If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "p",
            "type": "RealParameter",
            "description": "probability p parameter. Must be either size 1 for iid trials, or the same dimension as trials parameter if inhomogeneous bernoulli process.",
            "required": true
          },
          {
            "name": "parameter",
            "type": "BooleanParameter",
            "description": "the results of a series of bernoulli trials.",
            "required": false
          },
          {
            "name": "minSuccesses",
            "type": "IntegerParameter",
            "description": "Optional condition: the minimum number of ones in the boolean array.",
            "required": false
          }
        ]
      },
      {
        "name": "BetaRange",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.BetaRange",
        "description": "Expansion of the Beta distribution, except it respects the upper\/lower limits of the parameter  Can handle a different prior per parameter if the dimension of 'x' is equal to the dimension of the gamma parameters  If alpha \/ beta are set to 0, then the parameter will be skipped (ie. 0 log density)  If the parameter exceeds lower\/upper, the log density is negative infinity",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "x",
            "type": "RealParameter",
            "description": "the parameter at which the density is calculated",
            "required": true
          },
          {
            "name": "alpha",
            "type": "RealParameter",
            "description": "first shape parameter (default 1)",
            "required": false
          },
          {
            "name": "beta",
            "type": "RealParameter",
            "description": "the other shape parameter (default 1)",
            "required": false
          },
          {
            "name": "lower",
            "type": "RealParameter",
            "description": "lower limit of the parameter (default 0)",
            "required": false
          },
          {
            "name": "upper",
            "type": "RealParameter",
            "description": "upper limit of the parameter (default 1)",
            "required": false
          }
        ]
      },
      {
        "name": "ExcludablePrior",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.ExcludablePrior",
        "description": "Just as with Prior, produces log probability of the parameter x. This variant however allows one to explicitly exclude individual elements of multidimensional parameters from the result.",
        "generatorType": "distribution",
        "generatedType": "Function",
        "arguments": [
          {
            "name": "xInclude",
            "type": "BooleanParameter",
            "description": "Array of true\/false values specifying which elements of x to include",
            "required": true
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior, e.g. normal, beta, gamma.",
            "required": true
          }
        ]
      },
      {
        "name": "ExcludablePriorIndex",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.ExcludablePriorIndex",
        "description": "Just as with Prior, produces log probability of the parameter x. This variant however allows one to explicitly exclude individual elements of multidimensional parameters from the result using indexes that can be set to true, rather than requiring a TRUE\/FALSe entry for each parameter index.",
        "generatorType": "distribution",
        "generatedType": "Function",
        "arguments": [
          {
            "name": "xInclude",
            "type": "BooleanParameter",
            "description": "Array of true\/false values specifying which elements of x to include",
            "required": false
          },
          {
            "name": "xIncludeInteger",
            "type": "IntegerParameter",
            "description": "List of array indices to include  of x to include",
            "required": false
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior, e.g. normal, beta, gamma.",
            "required": true
          }
        ]
      },
      {
        "name": "GammaOneP",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.GammaOneP",
        "description": "One parameter (shape) gamma distribution, used as prior. Scale = 1\/shape, so that mean = 1.If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "shape",
            "type": "RealParameter",
            "description": "shape parameter, defaults to 1",
            "required": false
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "MixtureDistribution",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MixtureDistribution",
        "description": "Takes mixture of distributions",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "distribution",
            "type": "List<Distribution>",
            "description": "distribution to average over",
            "required": true,
            "default": "[]"
          },
          {
            "name": "weights",
            "type": "RealParameter",
            "description": "weights on the distributions, should sum to 1 if specified",
            "required": false
          },
          {
            "name": "useLogSpace",
            "type": "Boolean",
            "description": "if false (default) use sum_i w_i P_i, if true use sum_i w_i log(P_i). Note if useLogSpace=true, the resulting distribution is not normalised (unless one of the weights is 1), while if useLogSpace=false, the resulting distribution is normalised iff all mixture components are normalised.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "MonoPoints",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MonoPoints",
        "description": "Helper class for specifiying a set of monophyletic clades. This beast object is passed as an argument to another beast object, and provides the node id's of the clade roots upon request.The clades are collected from the various arguments and merged. Note that the mrca logger ignores the 'useOriginate' directive by design.",
        "generatorType": "function",
        "generatedType": "MonoPoints",
        "arguments": [
          {
            "name": "clades",
            "type": "List<MRCAPrior>",
            "description": "The set of clades represented as MRCAPriors",
            "required": false,
            "default": "[]"
          },
          {
            "name": "multiclades",
            "type": "MultiMRCAPriors",
            "description": "Set of clades represented as MultiMRCAPriors",
            "required": false
          },
          {
            "name": "constraints",
            "type": "MultiMonophyleticConstraint",
            "description": "all constraints as encoded by one unresolved tree.",
            "required": false
          }
        ]
      },
      {
        "name": "MRCAPriorWithRogues",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MRCAPriorWithRogues",
        "description": "Allow some rogue taxa to enter a monophyletic constraint",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "rogues",
            "type": "TaxonSet",
            "description": "set of taxa that may or may not part of the by monophyly constrained clade",
            "required": true
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa for which prior information is available",
            "required": false
          },
          {
            "name": "monophyletic",
            "type": "Boolean",
            "description": "whether the taxon set is monophyletic (forms a clade without other taxa) or nor. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior over MRCA time, e.g. normal, beta, gamma. If not specified, monophyletic must be true",
            "required": false
          },
          {
            "name": "tipsonly",
            "type": "Boolean",
            "description": "flag to indicate tip dates are to be used instead of the MRCA node. If set to true, the prior is applied to the height of all tips in the taxonset and the monophyletic flag is ignored. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "useOriginate",
            "type": "Boolean",
            "description": "Use parent of clade instead of clade. Cannot be used with tipsonly, or on the root.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "MultiMonophyleticConstraint",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MultiMonophyleticConstraint",
        "description": "Prior over set of taxa, useful for defining multiple monophyletic constraints using a newick format",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "the tree containing the taxon set",
            "required": true
          },
          {
            "name": "newick",
            "type": "String",
            "description": "the tree constraints specified as newick tree using polytopes, e.g. ((human,chimp,bonobo),gorilla) specifies two monophyletic constraints,one for human,chimp,bonobo' and one for 'human,chimp,bonobo,gorilla'\nMake sure the starting tree is compatible with these constraints.",
            "required": true
          },
          {
            "name": "isBinary",
            "type": "Boolean",
            "description": "flag to indicate tree is a binary tree instead of a polytopy (faster)",
            "required": false,
            "default": "true"
          },
          {
            "name": "robust",
            "type": "Boolean",
            "description": "flag to indicate a more robust algorithm should be used (slower)",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "MultiMRCAPriors",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.MultiMRCAPriors",
        "description": "A single distribution which efficiently takes care of a set of MRCA constraints.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "distribution",
            "type": "List<MRCAPrior>",
            "description": "Set of calibrated nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "the tree containing the taxon set",
            "required": true
          },
          {
            "name": "newick",
            "type": "String",
            "description": "the tree constraints specified as newick tree using polytopes, e.g. ((human,chimp,bonobo),gorilla) specifies two monophyletic constraints,one for human,chimp,bonobo' and one for 'human,chimp,bonobo,gorilla'\nMake sure the starting tree is compatible with these constraints.",
            "required": true
          },
          {
            "name": "isBinary",
            "type": "Boolean",
            "description": "flag to indicate tree is a binary tree instead of a polytopy (faster)",
            "required": false,
            "default": "true"
          },
          {
            "name": "robust",
            "type": "Boolean",
            "description": "flag to indicate a more robust algorithm should be used (slower)",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "SingleParamGamma",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.SingleParamGamma",
        "description": "Gamma distribution in which the scale parameter is forced to equal the reciprocal of the shape parameter. This fixes the mean at 1.0.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "RealParameter",
            "description": "shape parameter, defaults to 2",
            "required": false
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "WeibullDistribution",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.WeibullDistribution",
        "description": "Weibull distribution. for x>0  f(x;shape,scale) = scale\/shape(x\/shape)^{scale-1}e^{-(x\/shape)^scale}",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "shape",
            "type": "RealParameter",
            "description": "shape parameter, defaults to 1",
            "required": false
          },
          {
            "name": "scale",
            "type": "RealParameter",
            "description": "scale parameter, defaults to 1 unless meanOne=true, then scale is set to 1\/Gamma(1+shape) so mean of the distribution = 1",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "meanOne",
            "type": "Boolean",
            "description": "Fix mean to one, ignore scale parameter",
            "required": false,
            "default": "false"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "WeightedDirichlet",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.math.distributions.WeightedDirichlet",
        "description": "Weighted Dirichlet distribution that scales dimensions by weight",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "RealParameter",
            "description": "coefficients of the scaled Dirichlet distribution",
            "required": true
          },
          {
            "name": "weights",
            "type": "IntegerParameter",
            "description": "weights of the scaled Dirichlet distribution",
            "required": true
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "FitchParsimony",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.parsimony.FitchParsimony",
        "description": "Reconstructing characters using Fitch parsimony",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "FitchParsimony"
      },
      {
        "name": "PrevalenceLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.prevalence.PrevalenceLikelihood",
        "description": "likelihood of the prevalence sequence based on a set of parameters",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "beta",
            "type": "RealParameter",
            "description": "parameter for x y z",
            "required": true
          },
          {
            "name": "gamma",
            "type": "RealParameter",
            "description": "parameter for x y z",
            "required": true
          },
          {
            "name": "popSize",
            "type": "IntegerParameter",
            "description": "parameter for x y z",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "list",
            "type": "PrevalenceList",
            "description": "prevalence list representing infection\/recovery times",
            "required": true
          }
        ]
      },
      {
        "name": "PrevalenceList",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.prevalence.PrevalenceList",
        "description": "Prevalence list is a linked list with times and actions",
        "generatorType": "function",
        "generatedType": "PrevalenceList",
        "arguments": [
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "TreeForPrevalenceLikelihood",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.prevalence.TreeForPrevalenceLikelihood",
        "description": "likelihood of a tree conditioned on a prevalence sequence",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "initialTime",
            "type": "Double",
            "description": "initial start time for prevalence curve, defaults to root height times 2",
            "required": false
          },
          {
            "name": "list",
            "type": "PrevalenceList",
            "description": "prevalence list representing infection\/recovery times",
            "required": true
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "beast tree associated with list",
            "required": true
          }
        ]
      },
      {
        "name": "TraceStateNodeSource",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.tools.TraceStateNodeSource",
        "description": "Source of state node parameter values for post hoc analysis",
        "generatorType": "function",
        "generatedType": "TraceStateNodeSource",
        "arguments": [
          {
            "name": "trace",
            "type": "LogFile",
            "description": "Trace logs containing parameter settings. First trace log should contain posterior.",
            "required": false,
            "default": "[[none]]"
          },
          {
            "name": "value",
            "type": "String",
            "description": "comma delimited string of map enties. Each entry maps a trace label to a state node entry. Use square brackets to indicate the dimension. For example kappa.s:dna=kappa, freq.s:dna[0]=freq.A, freq.s:dna[1]=freq.C If no index is given in brackets, the first match in the trace will be assigned to index 0 and all consecutive matches to consecutive indices, e.g. freq.s:dna[]=freq.1 is equivalent to freq.s:dna[0]=freq.1,freq.s:dna[1]=freq.2,freq.s:dna[2]=freq.3,freq.s:dna[3]=freq.4",
            "required": false
          },
          {
            "name": "state",
            "type": "State",
            "description": "elements of the state space",
            "required": false
          }
        ]
      },
      {
        "name": "TreeStateNodeSource",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.tools.TreeStateNodeSource",
        "description": "Source of trees for post hoc analysis",
        "generatorType": "function",
        "generatedType": "TreeStateNodeSource",
        "arguments": [
          {
            "name": "treefile",
            "type": "TreeFile",
            "description": "Tree log containing trees from the posterior.",
            "required": false,
            "default": "[[none]]"
          },
          {
            "name": "treeID",
            "type": "String",
            "description": "id of the tree that should be initialised from the tree file",
            "required": false
          },
          {
            "name": "state",
            "type": "State",
            "description": "elements of the state space",
            "required": false
          },
          {
            "name": "value",
            "type": "String",
            "description": "comma delimited string of map enties. Each entry maps a meta data label to a state node entry. For example BranchRates.c:dna=rate",
            "required": false
          }
        ]
      },
      {
        "name": "BEASTVector",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.BEASTVector",
        "description": "array of beast objects",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "BEASTVector"
      },
      {
        "name": "Script",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Script",
        "description": "Base class for Script-BEAST interoperation",
        "generatorType": "function",
        "generatedType": "Script",
        "arguments": [
          {
            "name": "value",
            "type": "String",
            "description": "Script script needed for the calculations. It assumes there is a function f defined, which returns a single number or array of numbers.",
            "required": false
          },
          {
            "name": "expression",
            "type": "String",
            "description": "expression representing the calculations",
            "required": false
          },
          {
            "name": "x",
            "type": "List<Function>",
            "description": "Parameters needed for the calculations",
            "required": false,
            "default": "[]"
          },
          {
            "name": "argnames",
            "type": "String",
            "description": "names of arguments used in expression (space delimited), order as given by XML",
            "required": false
          },
          {
            "name": "engine",
            "type": "Script.Engine",
            "description": "Script needed for the calculations (one of [JavaScript, python, jruby, groovy] default Javascript)",
            "required": false,
            "default": "JavaScript"
          }
        ]
      },
      {
        "name": "Transform.Array",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Array",
        "description": "Applies list of transforms to individual dimensions of a parameter",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Transform.Array"
      },
      {
        "name": "Transform.Collection",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Collection",
        "description": "Applies list of parsed transforms to segments (=contiguous subsets of dimensions?) of a parameter",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Transform.Collection"
      },
      {
        "name": "Transform.Compose",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Compose",
        "description": "Composable transform: apply inner transforms first, then outer transform on the result",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Transform.Compose"
      },
      {
        "name": "Transform.ComposeMultivariable",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$ComposeMultivariable",
        "description": "Composes transform by applying outer transform to inner transform",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Transform.ComposeMultivariable"
      },
      {
        "name": "Transform.FisherZTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$FisherZTransform",
        "description": "Fisher Z-transform for univariables",
        "generatorType": "function",
        "generatedType": "Transform.FisherZTransform",
        "arguments": [
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Transform.Inverse",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$Inverse",
        "description": "Inverse transform for univariables",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Transform.Inverse"
      },
      {
        "name": "Transform.InverseMultivariate",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$InverseMultivariate",
        "description": "Inverse transforms multiple parameters or trees",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Transform.InverseMultivariate"
      },
      {
        "name": "Transform.LogConstrainedSumTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$LogConstrainedSumTransform",
        "description": "Transform on parameters that sum to a fixed value (e.g. nucleotide frequencies)",
        "generatorType": "function",
        "generatedType": "Transform.LogConstrainedSumTransform",
        "arguments": [
          {
            "name": "sum",
            "type": "Double",
            "description": "sum of the items",
            "required": false,
            "default": "1.0"
          },
          {
            "name": "weights",
            "type": "Double[]",
            "description": "weights of individual items",
            "required": false
          },
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Transform.LogitTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$LogitTransform",
        "description": "Logit transform for univariables",
        "generatorType": "function",
        "generatedType": "Transform.LogitTransform",
        "arguments": [
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Transform.LogTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$LogTransform",
        "description": "Log transform for univariables",
        "generatorType": "function",
        "generatedType": "Transform.LogTransform",
        "arguments": [
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Transform.NegateTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$NegateTransform",
        "description": "Negate transform for univariables",
        "generatorType": "function",
        "generatedType": "Transform.NegateTransform",
        "arguments": [
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Transform.NoTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$NoTransform",
        "description": "No transform for univariables = transform that leaves the variable unchanged",
        "generatorType": "function",
        "generatedType": "Transform.NoTransform",
        "arguments": [
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Transform.NoTransformMultivariable",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$NoTransformMultivariable",
        "description": "Transform that leaves multi parameter the same",
        "generatorType": "function",
        "generatedType": "Transform.NoTransformMultivariable",
        "arguments": [
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Transform.PositiveOrdered",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$PositiveOrdered",
        "description": "Log transform on difference between consecutive entries. Entries must be increasing in order.",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "Transform.PositiveOrdered"
      },
      {
        "name": "Transform.PowerTransform",
        "package": "BEASTLabs",
        "fullyQualifiedName": "beastlabs.util.Transform$PowerTransform",
        "description": "Power transform for univariables",
        "generatorType": "function",
        "generatedType": "Transform.PowerTransform",
        "arguments": [
          {
            "name": "f",
            "type": "List<Function>",
            "description": "parameter to be transformed",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "SampleTimeLog",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.core.SampleTimeLog",
        "description": "BEAST2 SampleTimeLog",
        "generatorType": "function",
        "generatedType": "SampleTimeLog",
        "arguments": [
          {
            "name": "schedule",
            "type": "OperatorSchedule",
            "description": "The oeprator schedule, used for determining number of proposals",
            "required": true
          }
        ]
      },
      {
        "name": "SpeciesTreeLogger",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.core.SpeciesTreeLogger",
        "description": "Logs tree annotated with metadata in StarBeast format",
        "generatorType": "function",
        "generatedType": "SpeciesTreeLogger",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree to be logged",
            "required": true
          },
          {
            "name": "popSize",
            "type": "Function",
            "description": "population size parameter associated with tree nodes",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "popSizeTop",
            "type": "Function",
            "description": "population size parameter associated with top of tree branches, only used for non-constant *beast analysis",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "speciesTreePrior",
            "type": "SpeciesTreePrior",
            "description": "species tree prior, used to find which Population Size Function is used. If not specified, assumes 'constant'",
            "required": false
          },
          {
            "name": "treetop",
            "type": "TreeTopFinder",
            "description": "calculates height of species tree",
            "required": true
          },
          {
            "name": "metadata",
            "type": "List<Function>",
            "description": "meta data to be logged with the tree nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "sort",
            "type": "Boolean",
            "description": "whether to sort the tree before logging.",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "StarBeastStartState",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.core.StarBeastStartState",
        "description": "Set a starting point for a *BEAST analysis from gene alignment data.",
        "generatorType": "function",
        "generatedType": "StarBeastStartState",
        "arguments": [
          {
            "name": "method",
            "type": "StarBeastStartState.Method",
            "description": "Initialise either with a totally random state or a point estimate based on alignments data (default point-estimate)",
            "required": false,
            "default": "point-estimate"
          },
          {
            "name": "speciesTree",
            "type": "Tree",
            "description": "The species tree to initialize",
            "required": false
          },
          {
            "name": "fixed",
            "type": "TreeParser",
            "description": "Optionally provide a newick of the species tree to use at start state",
            "required": false
          },
          {
            "name": "gene",
            "type": "List<Tree>",
            "description": "Gene trees to initialize",
            "required": false,
            "default": "[]"
          },
          {
            "name": "calibratedYule",
            "type": "CalibratedYuleModel",
            "description": "The species tree (with calibrations) to initialize",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "popMean",
            "type": "RealParameter",
            "description": "Population mean hyper prior to initialse",
            "required": false
          },
          {
            "name": "origin",
            "type": "List<RealParameter>",
            "description": "Species tree origin height",
            "required": false,
            "default": "[]"
          },
          {
            "name": "originLength",
            "type": "List<RealParameter>",
            "description": "Species tree origin branch length",
            "required": false,
            "default": "[]"
          },
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "Tree prior birth rate to initialize",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "speciesTreePrior",
            "type": "SpeciesTreePrior",
            "description": "Population size parameters to initialise",
            "required": false
          },
          {
            "name": "baseRate",
            "type": "Function",
            "description": "Main clock rate used to scale trees (default 1).",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rootHeight",
            "type": "Function",
            "description": "Initial root height (default at substitution length)",
            "required": false
          },
          {
            "name": "speciesTreeRates",
            "type": "BranchRateModelSB3",
            "description": "Clock model for species tree",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "sharedRateModel",
            "type": "SharedSpeciesClockModel",
            "description": "Clock model for species tree (instead of speciesTreeRates)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "kernel",
            "type": "GTKPrior",
            "description": "Clock model for species tree",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "RandomLocalClockModelSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.RandomLocalClockModelSB3",
        "description": "Based on RandomLocalClockModel in BEAST v2.4",
        "generatorType": "function",
        "generatedType": "RandomLocalClockModelSB3",
        "arguments": [
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "(Species) tree to apply per-branch rates to.",
            "required": true
          },
          {
            "name": "noCache",
            "type": "Boolean",
            "description": "Always recalculate branch rates.",
            "required": false,
            "default": "false"
          },
          {
            "name": "rates",
            "type": "RealParameter",
            "description": "Continuous per-branch rates.",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "indicators",
            "type": "BooleanParameter",
            "description": "Indicators associated with nodes in the tree for sampling of individual rate changes among branches.",
            "required": true
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "SharedSpeciesClockModel",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.SharedSpeciesClockModel",
        "description": "BEAST2 SharedSpeciesClockModel",
        "generatorType": "function",
        "generatedType": "SharedSpeciesClockModel",
        "arguments": [
          {
            "name": "branchRateModel",
            "type": "BranchRateModelSB3",
            "description": "Species tree branch rate model",
            "required": true,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "StarBeast3Clock",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.StarBeast3Clock",
        "description": "BEAST2 StarBeast3Clock",
        "generatorType": "function",
        "generatedType": "StarBeast3Clock",
        "arguments": [
          {
            "name": "speciesTreeRates",
            "type": "BranchRateModelSB3",
            "description": "The real branch rate model of the species tree",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "sharedRateModel",
            "type": "SharedSpeciesClockModel",
            "description": "Clock model for species tree (instead of speciesTreeRates)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "the gene tree",
            "required": false
          },
          {
            "name": "speciesTree",
            "type": "SpeciesTree",
            "description": "the species tree",
            "required": false
          },
          {
            "name": "geneTree",
            "type": "GeneTreeForSpeciesTreeDistribution",
            "description": "The gene tree this relaxed clock is associated with.",
            "required": false
          },
          {
            "name": "kernel",
            "type": "GTKPrior",
            "description": "the kernel of gene trees",
            "required": false
          },
          {
            "name": "pointer",
            "type": "GTKPointerTree",
            "description": "the tree which points to the kernel",
            "required": false
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "StrictClockModelSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.StrictClockModelSB3",
        "description": "BEAST2 StrictClockModelSB3",
        "generatorType": "function",
        "generatedType": "StrictClockModelSB3",
        "arguments": [
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "(Species) tree to apply per-branch rates to.",
            "required": true
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "UCRelaxedClockModelSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.branchratemodel.UCRelaxedClockModelSB3",
        "description": "BEAST2 UCRelaxedClockModelSB3",
        "generatorType": "function",
        "generatedType": "UCRelaxedClockModelSB3",
        "arguments": [
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "(Species) tree to apply per-branch rates to.",
            "required": true
          },
          {
            "name": "estimateRoot",
            "type": "Boolean",
            "description": "Estimate rate of the root branch.",
            "required": false,
            "default": "false"
          },
          {
            "name": "noCache",
            "type": "Boolean",
            "description": "Always recalculate branch rates.",
            "required": false,
            "default": "false"
          },
          {
            "name": "stdev",
            "type": "RealParameter",
            "description": "Standard deviation of the log-normal distribution for branch rates. If not supplied uses exponential.",
            "required": false
          },
          {
            "name": "discreteRates",
            "type": "IntegerParameter",
            "description": "The rate categories associated with nodes in the species tree for sampling of individual rates among branches.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "realRates",
            "type": "RealParameter",
            "description": "The real rates associated with nodes in the species tree for sampling of individual rates among branches.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateQuantiles",
            "type": "RealParameter",
            "description": "The rate quantiles for sampling of individual rates among branches.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "nBins",
            "type": "Integer",
            "description": "Number of discrete branch rate bins (default is equal to the number of estimated branch rates). Only used when branch rates are catrgories.",
            "required": false,
            "default": "-1"
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "the distribution governing the rates among branches, for quantiles only. Must have mean of 1. The clock.rate parameter can be used to change the mean rate.",
            "required": false
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "BirthProcess",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.BirthProcess",
        "description": "Gene lineages are assumed to diverge under a speciation process, constrained within species tree",
        "generatorType": "function",
        "generatedType": "BirthProcess",
        "arguments": [
          {
            "name": "speciesTree",
            "type": "SpeciesTree",
            "description": "The species tree this population model is assoicated with.",
            "required": true
          },
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "Per-branch birth rate.",
            "required": true,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "ConstantPopulations",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.ConstantPopulations",
        "description": "BEAST2 ConstantPopulations",
        "generatorType": "function",
        "generatedType": "ConstantPopulations",
        "arguments": [
          {
            "name": "speciesTree",
            "type": "SpeciesTree",
            "description": "The species tree this population model is assoicated with.",
            "required": true
          },
          {
            "name": "populationSizes",
            "type": "RealParameter",
            "description": "Constant per-branch population sizes.",
            "required": true,
            "constraint": "positive-integer"
          }
        ]
      },
      {
        "name": "GeneTreeForSpeciesTreeDistribution",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.GeneTreeForSpeciesTreeDistribution",
        "description": "Calculates probability of gene tree conditioned on a species tree (multi-species coalescent)",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "tree over which to calculate a prior or likelihood",
            "required": true
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          },
          {
            "name": "speciesTree",
            "type": "SpeciesTree",
            "description": "species tree containing the associated gene tree",
            "required": true
          },
          {
            "name": "ploidy",
            "type": "Double",
            "description": "ploidy (copy number) for this gene, typically a whole number or half (default 2 for autosomal_nuclear)",
            "required": false,
            "default": "2.0"
          },
          {
            "name": "sampling",
            "type": "Boolean",
            "description": "Set to true if using this class for simulating sequences",
            "required": false,
            "default": "false"
          },
          {
            "name": "speciesTreePrior",
            "type": "SpeciesTreePrior",
            "description": "defines population function and its parameters",
            "required": false
          },
          {
            "name": "populationModel",
            "type": "PopulationModel",
            "description": "Population model used to infer the multispecies coalescent probability for this gene",
            "required": false
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa mapping lineages to species",
            "required": false
          }
        ]
      },
      {
        "name": "SpeciesTreePrior",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.evolution.speciation.SpeciesTreePrior",
        "description": "Species tree prior for *BEAST analysis",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "popFunction",
            "type": "SpeciesTreePrior.TreePopSizeFunction",
            "description": "Population function. This can be [constant, linear, linear_with_constant_root] (default 'constant')",
            "required": false,
            "default": "constant"
          },
          {
            "name": "bottomPopSize",
            "type": "RealParameter",
            "description": "population size parameter for populations at the bottom of a branch. For linear population function, this is the same at the top of the branch.",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "topPopSize",
            "type": "RealParameter",
            "description": "population size parameter at the top of a branch. Ignored for constant population function, but required for linear population function.",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "gammaParameter",
            "type": "RealParameter",
            "description": "scale parameter of the gamma distribution over population sizes. This makes this parameter half the expected population size on all branches for constant population function, but a quarter of the expected population size for tip branches only for linear population functions.",
            "required": true
          },
          {
            "name": "populationModel",
            "type": "PopulationModel",
            "description": "Population model used to infer the multispecies coalescent probability",
            "required": true
          },
          {
            "name": "treePrior",
            "type": "TreeDistribution",
            "description": "Prior distribution behind the species tree",
            "required": false
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa mapping lineages to species",
            "required": true
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "GeneTreeKernel",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GeneTreeKernel",
        "description": "BEAST2 GeneTreeKernel",
        "generatorType": "function",
        "generatedType": "GeneTreeKernel",
        "arguments": [
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "GTKGeneTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GTKGeneTree",
        "description": "BEAST2 GTKGeneTree",
        "generatorType": "function",
        "generatedType": "GTKGeneTree",
        "arguments": [
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "GTKPointerTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GTKPointerTree",
        "description": "BEAST2 GTKPointerTree",
        "generatorType": "function",
        "generatedType": "GTKPointerTree",
        "arguments": [
          {
            "name": "kernel",
            "type": "GeneTreeKernel",
            "description": "The gene tree kernel which contains a set of trees",
            "required": true
          },
          {
            "name": "indicator",
            "type": "IntegerParameter",
            "description": "A parameter which points each observed gene tree to one in the kernel",
            "required": true
          },
          {
            "name": "index",
            "type": "Integer",
            "description": "Indexes this tree into the 'indicator'. An integer from 0 to g-1, where g is the number of gene trees.",
            "required": true
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "GTKPrior",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.genekernel.GTKPrior",
        "description": "BEAST2 GTKPrior",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "pointer",
            "type": "List<GTKPointerTree>",
            "description": "Gene trees which point to the kernel trees",
            "required": false,
            "default": "[]"
          },
          {
            "name": "kernel",
            "type": "GeneTreeKernel",
            "description": "The gene tree kernel which contains a set of trees",
            "required": true
          },
          {
            "name": "geneKernelSize",
            "type": "IntegerParameter",
            "description": "The parameter governing the gene kernel size",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "indicator",
            "type": "IntegerParameter",
            "description": "A parameter which points each observed gene tree to one in the kernel",
            "required": true
          },
          {
            "name": "speciesTree",
            "type": "SpeciesTree",
            "description": "species tree containing the associated gene tree",
            "required": true
          },
          {
            "name": "ploidy",
            "type": "Double",
            "description": "ploidy (copy number) for this gene, typically a whole number or half (default 2 for autosomal_nuclear)",
            "required": false,
            "default": "2.0"
          },
          {
            "name": "sampling",
            "type": "Boolean",
            "description": "Set to true if using this class for simulating sequences",
            "required": false,
            "default": "false"
          },
          {
            "name": "speciesTreePrior",
            "type": "SpeciesTreePrior",
            "description": "defines population function and its parameters",
            "required": false
          },
          {
            "name": "populationModel",
            "type": "PopulationModel",
            "description": "Population model used to infer the multispecies coalescent probability for this gene",
            "required": false
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa mapping lineages to species",
            "required": false
          },
          {
            "name": "pointerPrior",
            "type": "Boolean",
            "description": "If true, only tree pointers have prior density (except for illegal kernal trees which are rejected). If false,only kernel trees have prior density. ",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "InverseGamma",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.math.distributions.InverseGamma",
        "description": "Inverse Gamma distribution, used as prior.    for x>0  f(x; alpha, beta) = \frac{beta^alpha}{Gamma(alpha)} (1\/x)^{alpha + 1}exp(-beta\/x) If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "RealParameter",
            "description": "shape parameter, defaults to 2",
            "required": false
          },
          {
            "name": "beta",
            "type": "RealParameter",
            "description": "scale parameter, defaults to 2",
            "required": false
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "MRCAPriorSB3",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.math.distributions.MRCAPriorSB3",
        "description": "Behaves the same as a MRCAPrior, but allows BEAUti to know how to add the correct operators for tips sampling",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa for which prior information is available",
            "required": false
          },
          {
            "name": "monophyletic",
            "type": "Boolean",
            "description": "whether the taxon set is monophyletic (forms a clade without other taxa) or nor. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior over MRCA time, e.g. normal, beta, gamma. If not specified, monophyletic must be true",
            "required": false
          },
          {
            "name": "tipsonly",
            "type": "Boolean",
            "description": "flag to indicate tip dates are to be used instead of the MRCA node. If set to true, the prior is applied to the height of all tips in the taxonset and the monophyletic flag is ignored. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "useOriginate",
            "type": "Boolean",
            "description": "Use parent of clade instead of clade. Cannot be used with tipsonly, or on the root.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "BinaryNode",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.BinaryNode",
        "description": "BEAST2 BinaryNode",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "BinaryNode"
      },
      {
        "name": "BinaryTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.BinaryTree",
        "description": "Binary tree with efficient store\/restore",
        "generatorType": "function",
        "generatedType": "BinaryTree",
        "arguments": [
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "SpeciesTree",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.SpeciesTree",
        "description": "BEAST2 SpeciesTree",
        "generatorType": "function",
        "generatedType": "SpeciesTree",
        "arguments": [
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "StarBeast3TaxonSet",
        "package": "starbeast3",
        "fullyQualifiedName": "starbeast3.tree.StarBeast3TaxonSet",
        "description": "A TaxonSet is an ordered set of taxa. The order on the taxa is provided at the time of construction either from a list of taxon objects or an alignment.",
        "generatorType": "function",
        "generatedType": "StarBeast3TaxonSet",
        "arguments": [
          {
            "name": "alignment",
            "type": "Alignment",
            "description": "alignment where each sequence represents a taxon",
            "required": false
          },
          {
            "name": "taxon",
            "type": "List<Taxon>",
            "description": "list of taxa making up the set",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "Function.Constant",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.core.Function$Constant",
        "description": "Function that does not change over time",
        "generatorType": "function",
        "generatedType": "Function.Constant",
        "arguments": []
      },
      {
        "name": "VirtualBEASTObject",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.core.VirtualBEASTObject",
        "description": "BEAST Object that encapsulates an object that does not implement BEASTInterface",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "VirtualBEASTObject"
      },
      {
        "name": "Alignment",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.Alignment",
        "description": "Class representing alignment data",
        "generatorType": "function",
        "generatedType": "Alignment",
        "arguments": [
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "AscertainedAlignment",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.AscertainedAlignment",
        "description": "Alignemnt that allows ascertainment correction",
        "generatorType": "function",
        "generatedType": "AscertainedAlignment",
        "arguments": [
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "FilteredAlignment",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.FilteredAlignment",
        "description": "Alignment based on a filter operation on another alignment",
        "generatorType": "function",
        "generatedType": "FilteredAlignment",
        "arguments": [
          {
            "name": "filter",
            "type": "String",
            "description": "specifies which of the sites in the input alignment should be selected First site is 1.Filter specs are comma separated, either a singleton, a range [from]-[to] or iteration [from]:[to]:[step]; 1-100 defines a range, 1-100\u0003 or 1:100:3 defines every third in range 1-100, 1::3,2::3 removes every third site. Default for range [1]-[last site], default for iterator [1]:[last site]:[1]",
            "required": true
          },
          {
            "name": "data",
            "type": "Alignment",
            "description": "alignment to be filtered",
            "required": true
          },
          {
            "name": "constantSiteWeights",
            "type": "IntegerParameter",
            "description": "if specified, constant sites will be added with weights specified by the input. The dimension and order of weights must match the datatype. For example for nucleotide data, a 4 dimensional parameter with weights for A, C, G and T respectively need to be specified.",
            "required": false
          },
          {
            "name": "sequence",
            "type": "List<Sequence>",
            "description": "sequence and meta data for particular taxon",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "An optional taxon-set used only to sort the sequences into the same order as they appear in the taxon-set.",
            "required": false,
            "default": "\tnull\n"
          },
          {
            "name": "statecount",
            "type": "Integer",
            "description": "maximum number of states in all sequences",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "dataType",
            "type": "String",
            "description": "data type, one of {aminoacid=aminoacid, binary=binary, integer=integer, nucleotide=nucleotide, standard=standard, twoStateCovarion=twoStateCovarion, user defined=user defined}",
            "required": false,
            "default": "nucleotide"
          },
          {
            "name": "userDataType",
            "type": "DataType.Base",
            "description": "non-standard, user specified data type, if specified 'dataType' is ignored",
            "required": false
          },
          {
            "name": "strip",
            "type": "Boolean",
            "description": "sets weight to zero for sites that are invariant (e.g. all 1, all A or all unkown)",
            "required": false,
            "default": "false"
          },
          {
            "name": "weights",
            "type": "String",
            "description": "comma separated list of weights, one for each site in the sequences. If not specified, each site has weight 1",
            "required": false
          },
          {
            "name": "ascertained",
            "type": "Boolean",
            "description": "is true if the alignment allows ascertainment correction, i.e., conditioning the Felsenstein likelihood on excluding constant sites from the alignment",
            "required": false,
            "default": "false"
          },
          {
            "name": "excludefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeto",
            "type": "Integer",
            "description": "last site to condition on (but excluding this site), default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "excludeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "includefrom",
            "type": "Integer",
            "description": "first site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeto",
            "type": "Integer",
            "description": "last site to condition on, default 0",
            "required": false,
            "default": "0"
          },
          {
            "name": "includeevery",
            "type": "Integer",
            "description": "interval between sites to condition on (default 1)",
            "required": false,
            "default": "1"
          },
          {
            "name": "*",
            "type": "Map",
            "description": "Input containing the map",
            "required": false,
            "default": "{}"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "Sequence",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.Sequence",
        "description": "Single sequence in an alignment.",
        "generatorType": "function",
        "generatedType": "Sequence",
        "arguments": [
          {
            "name": "totalcount",
            "type": "Integer",
            "description": "number of states or the number of lineages for this species in SNAPP analysis",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "taxon",
            "type": "String",
            "description": "name of this species",
            "required": true
          },
          {
            "name": "value",
            "type": "String",
            "description": "sequence data, either encoded as a string or as comma separated list of integers, or comma separated likelihoods\/probabilities for each site if uncertain=true.In either case, whitespace is ignored.",
            "required": true
          },
          {
            "name": "uncertain",
            "type": "Boolean",
            "description": "if true, sequence is provided as comma separated probabilities for each character, with sites separated by a semi-colons. In this formulation, gaps are coded as 1\/K,...,1\/K, where K is the number of states in the model.",
            "required": false
          }
        ]
      },
      {
        "name": "Taxon",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.Taxon",
        "description": "For identifying a single taxon",
        "generatorType": "function",
        "generatedType": "Taxon",
        "arguments": []
      },
      {
        "name": "TaxonSet",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.alignment.TaxonSet",
        "description": "A TaxonSet is an ordered set of taxa. The order on the taxa is provided at the time of construction either from a list of taxon objects or an alignment.",
        "generatorType": "function",
        "generatedType": "TaxonSet",
        "arguments": [
          {
            "name": "alignment",
            "type": "Alignment",
            "description": "alignment where each sequence represents a taxon",
            "required": false
          },
          {
            "name": "taxon",
            "type": "List<Taxon>",
            "description": "list of taxa making up the set",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "RandomLocalClockModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.RandomLocalClockModel",
        "description": "Random Local Clock Model.",
        "generatorType": "function",
        "generatedType": "RandomLocalClockModel",
        "arguments": [
          {
            "name": "indicators",
            "type": "BooleanParameter",
            "description": "the indicators associated with nodes in the tree for sampling of individual rate changes among branches.",
            "required": true
          },
          {
            "name": "rates",
            "type": "RealParameter",
            "description": "the rate parameters associated with nodes in the tree for sampling of individual rates among branches.",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "the tree this relaxed clock is associated with.",
            "required": true
          },
          {
            "name": "ratesAreMultipliers",
            "type": "Boolean",
            "description": "true if the rates should be treated as multipliers (default false).",
            "required": false,
            "default": "false",
            "constraint": "positive"
          },
          {
            "name": "scaling",
            "type": "Boolean",
            "description": "if false, then ignore meanRate input and leave rates unscaled.",
            "required": false,
            "default": "true"
          },
          {
            "name": "includeRoot",
            "type": "Boolean",
            "description": "if true, then the root can take on an arbitrary rate, otherwise the root branch has rate 1.0.",
            "required": false,
            "default": "false"
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "StrictClockModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.StrictClockModel",
        "description": "Defines a mean rate for each branch in the beast.tree.",
        "generatorType": "function",
        "generatedType": "StrictClockModel",
        "arguments": [
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "UCRelaxedClockModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.branchratemodel.UCRelaxedClockModel",
        "description": "Defines an uncorrelated relaxed molecular clock.",
        "generatorType": "function",
        "generatedType": "UCRelaxedClockModel",
        "arguments": [
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "the distribution governing the rates among branches. Must have mean of 1. The clock.rate parameter can be used to change the mean rate.",
            "required": true
          },
          {
            "name": "rateCategories",
            "type": "IntegerParameter",
            "description": "the rate categories associated with nodes in the tree for sampling of individual rates among branches.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "numberOfDiscreteRates",
            "type": "Integer",
            "description": "the number of discrete rates to approximate the rate distribution by. With category parameterisation, a value <= 0 will cause the number of categories to be set equal to the number of branches in the tree. With quantile parameterisation, a value <= 1 will calculate rates for every quantile, a value > 1 will approximate the distribution piecewise linearly with specified number of rates. (default = -1)",
            "required": false,
            "default": "-1",
            "constraint": "positive"
          },
          {
            "name": "rateQuantiles",
            "type": "RealParameter",
            "description": "the rate quantiles associated with nodes in the tree for sampling of individual rates among branches.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rates",
            "type": "RealParameter",
            "description": "the rates associated with nodes in the tree for sampling of individual rates among branches.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "the tree this relaxed clock is associated with.",
            "required": true
          },
          {
            "name": "normalize",
            "type": "Boolean",
            "description": "Whether to normalize the average rate (default false).",
            "required": false,
            "default": "false"
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "mean clock rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "Aminoacid",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.Aminoacid",
        "description": "DataType for amino acids.",
        "generatorType": "function",
        "generatedType": "Aminoacid",
        "arguments": []
      },
      {
        "name": "Binary",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.Binary",
        "description": "Datatype for binary sequences",
        "generatorType": "function",
        "generatedType": "Binary",
        "arguments": []
      },
      {
        "name": "IntegerData",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.IntegerData",
        "description": "Datatype for integer sequences",
        "generatorType": "function",
        "generatedType": "IntegerData",
        "arguments": []
      },
      {
        "name": "Nucleotide",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.Nucleotide",
        "description": "Nucleotide datatype for DNA sequences",
        "generatorType": "function",
        "generatedType": "Nucleotide",
        "arguments": []
      },
      {
        "name": "StandardData",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.StandardData",
        "description": "Integer data type to describe discrete morphological characters with polymorphisms",
        "generatorType": "function",
        "generatedType": "StandardData",
        "arguments": [
          {
            "name": "nrOfStates",
            "type": "Integer",
            "description": "specifies the maximum number of character states in data matrix or in the filtered alignment",
            "required": false
          },
          {
            "name": "ambiguities",
            "type": "String",
            "description": "all possible ambiguities presented as space separated sets of ordered elements. Elements are digits 0..9.",
            "required": false
          },
          {
            "name": "charstatelabels",
            "type": "List<UserDataType>",
            "description": "list of morphological character descriptions. Position in the list corresponds to the position of thecharacter in the alignment",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "TwoStateCovarion",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.TwoStateCovarion",
        "description": "Datatype for two state covarion sequences",
        "generatorType": "function",
        "generatedType": "TwoStateCovarion",
        "arguments": []
      },
      {
        "name": "UserDataType",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.datatype.UserDataType",
        "description": "User defined datatype. Allows custom symbols to map onto statesets.",
        "generatorType": "function",
        "generatedType": "UserDataType",
        "arguments": [
          {
            "name": "states",
            "type": "Integer",
            "description": "total number of states",
            "required": true
          },
          {
            "name": "codelength",
            "type": "Integer",
            "description": "length of code, if negative a variable length code is assumed, default 1",
            "required": false,
            "default": "1"
          },
          {
            "name": "codeMap",
            "type": "String",
            "description": "mapping of codes to states. A comma separated string of codes with a subset of states. A state set is a space separates list of zero based integers, up to the number of states, e.g. A=0, C=1, R=0 2, ? = 0 1 2 3",
            "required": true
          },
          {
            "name": "characterName",
            "type": "String",
            "description": "the name of the character",
            "required": false
          },
          {
            "name": "value",
            "type": "String",
            "description": "the list of the state names ordered according to codes given, that is the first in the list is coded by 0, second, by 1 and so forth.",
            "required": false
          }
        ]
      },
      {
        "name": "Distance.Base",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.Distance$Base",
        "description": "Provides distance between two sequences in an alignment",
        "generatorType": "function",
        "generatedType": "Distance.Base",
        "arguments": []
      },
      {
        "name": "F84Distance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.F84Distance",
        "description": "compute HKY corrected distance",
        "generatorType": "function",
        "generatedType": "F84Distance",
        "arguments": []
      },
      {
        "name": "HammingDistance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.HammingDistance",
        "description": "Hamming distance is the mean number of characters that differ between sequences. Note that unknowns are not ignored, so if both are unknowns '?' the distance is zero.",
        "generatorType": "function",
        "generatedType": "HammingDistance",
        "arguments": []
      },
      {
        "name": "JukesCantorDistance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.JukesCantorDistance",
        "description": "compute jukes-cantor corrected distance",
        "generatorType": "function",
        "generatedType": "JukesCantorDistance",
        "arguments": []
      },
      {
        "name": "SMMDistance",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.distance.SMMDistance",
        "description": "Calculate the distance between different microsatellite alleles",
        "generatorType": "function",
        "generatedType": "SMMDistance",
        "arguments": []
      },
      {
        "name": "BeagleTreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.BeagleTreeLikelihood",
        "description": "Uses Beagle library to calculate Tree likelihood",
        "generatorType": "distribution",
        "generatedType": "Alignment",
        "arguments": [
          {
            "name": "useAmbiguities",
            "type": "Boolean",
            "description": "flag to indicate that sites containing ambiguous states should be handled instead of ignored (the default)",
            "required": false,
            "default": "false"
          },
          {
            "name": "useTipLikelihoods",
            "type": "Boolean",
            "description": "flag to indicate that partial likelihoods are provided at the tips",
            "required": false,
            "default": "false"
          },
          {
            "name": "implementation",
            "type": "String",
            "description": "name of class that implements this treelikelihood potentially more efficiently. This class will be tried first, with the TreeLikelihood as fallback implementation. When multi-threading, multiple objects can be created.",
            "required": false,
            "default": "beast.evolution.likelihood.BeagleTreeLikelihood"
          },
          {
            "name": "scaling",
            "type": "TreeLikelihood.Scaling",
            "description": "type of scaling to use, one of [none, always, _default]. If not specified, the -beagle_scaling flag is used.",
            "required": false,
            "default": "_default"
          },
          {
            "name": "rootFrequencies",
            "type": "Frequencies",
            "description": "prior state frequencies at root, optional",
            "required": false
          },
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "phylogenetic beast.tree with sequence data in the leafs",
            "required": true
          },
          {
            "name": "siteModel",
            "type": "SiteModelInterface",
            "description": "site model for leafs in the beast.tree",
            "required": true
          },
          {
            "name": "branchRateModel",
            "type": "BranchRateModel.Base",
            "description": "A model describing the rates on the branches of the beast.tree.",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "GenericTreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.GenericTreeLikelihood",
        "description": "Generic tree likelihood for an alignment given a generic SiteModel, a beast tree and a branch rate model",
        "generatorType": "distribution",
        "generatedType": "Alignment",
        "arguments": [
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "phylogenetic beast.tree with sequence data in the leafs",
            "required": true
          },
          {
            "name": "siteModel",
            "type": "SiteModelInterface",
            "description": "site model for leafs in the beast.tree",
            "required": true
          },
          {
            "name": "branchRateModel",
            "type": "BranchRateModel.Base",
            "description": "A model describing the rates on the branches of the beast.tree.",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "ThreadedTreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.ThreadedTreeLikelihood",
        "description": "Calculates the likelihood of sequence data on a beast.tree given a site and substitution model using a variant of the 'peeling algorithm'. For details, seeFelsenstein, Joseph (1981). Evolutionary trees from DNA sequences: a maximum likelihood approach. J Mol Evol 17 (6): 368-376.",
        "generatorType": "distribution",
        "generatedType": "Alignment",
        "arguments": [
          {
            "name": "useAmbiguities",
            "type": "Boolean",
            "description": "flag to indicate leafs that sites containing ambiguous states should be handled instead of ignored (the default)",
            "required": false,
            "default": "false"
          },
          {
            "name": "threads",
            "type": "Integer",
            "description": "maximum number of threads to use, if less than 1 the number of threads in BeastMCMC is used (default -1)",
            "required": false,
            "default": "-1"
          },
          {
            "name": "proportions",
            "type": "String",
            "description": "specifies proportions of patterns used per thread as space delimited string. This is useful when using a mixture of BEAGLE devices that run at different speeds, e.g GPU and CPU. The string is duplicated if there are more threads than proportions specified. For example, '1 2' as well as '33 66' with 2 threads specifies that the first thread gets a third of the patterns and the second two thirds. With 3 threads, it is interpreted as '1 2 1' = 25%, 50%, 25% and with 7 threads it is '1 2 1 2 1 2 1' = 10% 20% 10% 20% 10% 20% 10%. If not specified, all threads get the same proportion of patterns.",
            "required": false
          },
          {
            "name": "scaling",
            "type": "ThreadedTreeLikelihood.Scaling",
            "description": "type of scaling to use, one of [none, always, _default]. If not specified, the -beagle_scaling flag is used.",
            "required": false,
            "default": "_default"
          },
          {
            "name": "rootFrequencies",
            "type": "Frequencies",
            "description": "prior state frequencies at root, optional",
            "required": false
          },
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "phylogenetic beast.tree with sequence data in the leafs",
            "required": true
          },
          {
            "name": "siteModel",
            "type": "SiteModelInterface",
            "description": "site model for leafs in the beast.tree",
            "required": true
          },
          {
            "name": "branchRateModel",
            "type": "BranchRateModel.Base",
            "description": "A model describing the rates on the branches of the beast.tree.",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "TreeLikelihood",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.likelihood.TreeLikelihood",
        "description": "Calculates the probability of sequence data on a beast.tree given a site and substitution model using a variant of the 'peeling algorithm'. For details, seeFelsenstein, Joseph (1981). Evolutionary trees from DNA sequences: a maximum likelihood approach. J Mol Evol 17 (6): 368-376.",
        "generatorType": "distribution",
        "generatedType": "Alignment",
        "arguments": [
          {
            "name": "useAmbiguities",
            "type": "Boolean",
            "description": "flag to indicate that sites containing ambiguous states should be handled instead of ignored (the default)",
            "required": false,
            "default": "false"
          },
          {
            "name": "useTipLikelihoods",
            "type": "Boolean",
            "description": "flag to indicate that partial likelihoods are provided at the tips",
            "required": false,
            "default": "false"
          },
          {
            "name": "implementation",
            "type": "String",
            "description": "name of class that implements this treelikelihood potentially more efficiently. This class will be tried first, with the TreeLikelihood as fallback implementation. When multi-threading, multiple objects can be created.",
            "required": false,
            "default": "beast.evolution.likelihood.BeagleTreeLikelihood"
          },
          {
            "name": "scaling",
            "type": "TreeLikelihood.Scaling",
            "description": "type of scaling to use, one of [none, always, _default]. If not specified, the -beagle_scaling flag is used.",
            "required": false,
            "default": "_default"
          },
          {
            "name": "rootFrequencies",
            "type": "Frequencies",
            "description": "prior state frequencies at root, optional",
            "required": false
          },
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "phylogenetic beast.tree with sequence data in the leafs",
            "required": true
          },
          {
            "name": "siteModel",
            "type": "SiteModelInterface",
            "description": "site model for leafs in the beast.tree",
            "required": true
          },
          {
            "name": "branchRateModel",
            "type": "BranchRateModel.Base",
            "description": "A model describing the rates on the branches of the beast.tree.",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "RateStatistic",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.RateStatistic",
        "description": "A statistic that tracks the mean, variance and coefficent of variation of rates. It has three dimensions, one for each statistic.",
        "generatorType": "function",
        "generatedType": "RateStatistic",
        "arguments": [
          {
            "name": "treeLikelihood",
            "type": "GenericTreeLikelihood",
            "description": "TreeLikelihood containing branch rate model that provides rates for a tree",
            "required": false
          },
          {
            "name": "branchratemodel",
            "type": "BranchRateModel",
            "description": "model that provides rates for a tree",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree for which the rates apply",
            "required": true
          },
          {
            "name": "internal",
            "type": "Boolean",
            "description": "consider internal nodes, default true",
            "required": false,
            "default": "true"
          },
          {
            "name": "external",
            "type": "Boolean",
            "description": "consider external nodes, default true",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "SiteModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.sitemodel.SiteModel",
        "description": "Defines mutation rate and gamma distributed rates across sites (optional) and proportion of the sites invariant (also optional).",
        "generatorType": "function",
        "generatedType": "SiteModel",
        "arguments": [
          {
            "name": "mutationRate",
            "type": "RealParameter",
            "description": "mutation rate (defaults to 1.0)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "gammaCategoryCount",
            "type": "Integer",
            "description": "gamma category count (default=zero for no gamma)",
            "required": false,
            "default": "0",
            "constraint": "positive-integer"
          },
          {
            "name": "shape",
            "type": "RealParameter",
            "description": "shape parameter of gamma distribution. Ignored if gammaCategoryCount 1 or less",
            "required": false
          },
          {
            "name": "proportionInvariant",
            "type": "RealParameter",
            "description": "proportion of sites that is invariant: should be between 0 (default) and 1",
            "required": false
          },
          {
            "name": "substModel",
            "type": "SubstitutionModel",
            "description": "substitution model along branches in the beast.tree",
            "required": true
          }
        ]
      },
      {
        "name": "BirthDeathGernhard08Model",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.BirthDeathGernhard08Model",
        "description": "Birth Death model based on Gernhard 2008. <br\/>This derivation conditions directly on fixed N taxa. <br\/>The inference is directly on b-d (strictly positive) and d\/b (constrained in [0,1)) <br\/>Verified using simulated trees generated by Klaas tree sample. (http:\/\/www.klaashartmann.com\/treesample\/) <br\/>Sampling proportion not verified via simulation. Proportion set by default to 1, an assignment which makes the expressions identical to the expressions before the change.",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "type",
            "type": "String",
            "description": "tree type, should be one of [unscaled, timesonly, oriented, labeled] (default unscaled)",
            "required": false,
            "default": "unscaled"
          },
          {
            "name": "relativeDeathRate",
            "type": "RealParameter",
            "description": "relative death rate parameter, mu\/lambda in birth death model (turnover parameter)",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "sampleProbability",
            "type": "RealParameter",
            "description": "sample probability, rho in birth\/death model",
            "required": false,
            "constraint": "probability"
          },
          {
            "name": "birthDiffRate",
            "type": "RealParameter",
            "description": "birth difference rate parameter, lambda - mu in birth\/death model (diversification rate)",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "originHeight",
            "type": "RealParameter",
            "description": "the height of the point of origin of the process",
            "required": false
          },
          {
            "name": "conditionalOnRoot",
            "type": "Boolean",
            "description": "Whether to condition on the root (default false)",
            "required": false,
            "default": "false"
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "CalibratedBirthDeathModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedBirthDeathModel",
        "description": "Birth-Death prior with calibrated monophyletic clades. With this prior, the marginal distribution of the calibrated nodes (the root age of the clade) is identical to the specified calibration, and the density ratio between trees with equal calibration values is equal to the ratio under the Birth-Death prior.",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "birth rate - the rate at which new lineages are created as a result of an existing lineage splitting into two.",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "relativeDeathRate",
            "type": "RealParameter",
            "description": "relative death rate parameter, mu\/lambda in birth death model",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "sampleProbability",
            "type": "RealParameter",
            "description": "sample probability, rho in birth\/death model",
            "required": false,
            "constraint": "probability"
          },
          {
            "name": "calibrations",
            "type": "List<CalibrationPoint>",
            "description": "Set of calibrated nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "type",
            "type": "CalibratedBirthDeathModel.Type",
            "description": "Type of correction: none for no correction (same as BEAST1), full for Yule-like over calibrated times, and restricted for Yule-like over calibrated times and ranked topology (default 'full'). However, 'full' is generally slow except for a few special cases, such as a single clade or two nested clades.",
            "required": false,
            "default": "full"
          },
          {
            "name": "logMarginal",
            "type": "RPNcalculator",
            "description": "Use provided formula to compute the (log of) the marginal for special cases.",
            "required": false
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "CalibratedYuleInitialTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedYuleInitialTree",
        "description": "A tree compatible with a set of monophyletic clades and hard limits on the clade root.",
        "generatorType": "function",
        "generatedType": "CalibratedYuleInitialTree",
        "arguments": [
          {
            "name": "calibrations",
            "type": "List<CalibrationPoint>",
            "description": "Set of calibrated nodes",
            "required": true,
            "default": "[]"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "CalibratedYuleModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibratedYuleModel",
        "description": "Yule prior with calibrated monophyletic clades. With this prior, the marginal distribution of the calibrated nodes (the MRCA of clades) is identical to the specified calibration, but the Yule is not preserved over the whole tree space, only among sub-spaces.",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "birth rate of splitting a linage into two",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "calibrations",
            "type": "List<CalibrationPoint>",
            "description": "Set of calibrated nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "type",
            "type": "CalibratedYuleModel.Type",
            "description": "Type of correction: none for no correction (same as BEAST1), full for Yule-like over calibrated times, and restricted for Yule-like over calibrated times and ranked topology (default 'full'). However, 'full' is generally slow except for in a few special cases, such as a single clade or two nested clades.",
            "required": false,
            "default": "full"
          },
          {
            "name": "logMarginal",
            "type": "RPNcalculator",
            "description": "Used provided correction (log of marginal) for special cases.",
            "required": false
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "CalibrationPoint",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.CalibrationPoint",
        "description": "Specification of a single calibration point of the calibrated Yule.",
        "generatorType": "function",
        "generatedType": "CalibrationPoint",
        "arguments": [
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "Set of taxa. The prior distribution is applied to their TMRCA.",
            "required": true
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "Prior distribution applied to time of clade MRCA",
            "required": true
          },
          {
            "name": "parentOf",
            "type": "Boolean",
            "description": "Use time of clade parent. Default is false.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "GeneTreeForSpeciesTreeDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.GeneTreeForSpeciesTreeDistribution",
        "description": "Calculates probability of gene tree conditioned on a species tree (multi-species coalescent)",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "speciesTree",
            "type": "TreeInterface",
            "description": "species tree containing the associated gene tree",
            "required": true
          },
          {
            "name": "ploidy",
            "type": "Double",
            "description": "ploidy (copy number) for this gene, typically a whole number or half (default 2 for autosomal_nuclear)",
            "required": false,
            "default": "2.0"
          },
          {
            "name": "speciesTreePrior",
            "type": "SpeciesTreePopFunction",
            "description": "defines population function and its parameters",
            "required": true
          },
          {
            "name": "treetop",
            "type": "TreeTopFinder",
            "description": "calculates height of species tree, required only for linear *beast analysis",
            "required": false
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "RandomGeneTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.RandomGeneTree",
        "description": "Generates a random gene tree conditioned on a species tree, such that the root of the species tree is lower than any coalescent events in the gene tree",
        "generatorType": "function",
        "generatedType": "RandomGeneTree",
        "arguments": [
          {
            "name": "speciesTree",
            "type": "Tree",
            "description": "The species tree in which this random gene tree needs to fit",
            "required": true
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "set of taxa to initialise tree specified by alignment",
            "required": false
          },
          {
            "name": "populationModel",
            "type": "PopulationFunction",
            "description": "population function for generating coalescent???",
            "required": true
          },
          {
            "name": "constraint",
            "type": "List<MRCAPrior>",
            "description": "specifies (monophyletic or height distribution) constraints on internal nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "rootHeight",
            "type": "Double",
            "description": "If specified the tree will be scaled to match the root height, if constraints allow this",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "SpeciesTreeLogger",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.SpeciesTreeLogger",
        "description": "Logs tree annotated with metadata in StarBeast format",
        "generatorType": "function",
        "generatedType": "SpeciesTreeLogger",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree to be logged",
            "required": true
          },
          {
            "name": "popSize",
            "type": "Function",
            "description": "population size parameter associated with tree nodes",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "popSizeTop",
            "type": "Function",
            "description": "population size parameter associated with top of tree branches, only used for non-constant *beast analysis",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "speciesTreePrior",
            "type": "SpeciesTreePrior",
            "description": "species tree prior, used to find which Population Size Function is used. If not specified, assumes 'constant'",
            "required": false
          },
          {
            "name": "treetop",
            "type": "TreeTopFinder",
            "description": "calculates height of species tree",
            "required": true
          },
          {
            "name": "metadata",
            "type": "List<Function>",
            "description": "meta data to be logged with the tree nodes",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "SpeciesTreePopFunction",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.SpeciesTreePopFunction",
        "description": "Species tree prior for *BEAST analysis",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "popFunction",
            "type": "SpeciesTreePopFunction.TreePopSizeFunction",
            "description": "Population function. This can be [constant, linear, linear_with_constant_root] (default 'constant')",
            "required": false,
            "default": "constant"
          },
          {
            "name": "bottomPopSize",
            "type": "RealParameter",
            "description": "population size parameter for populations at the bottom of a branch. For constant population function, this is the same at the top of the branch.",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "topPopSize",
            "type": "RealParameter",
            "description": "population size parameter at the top of a branch. Ignored for constant population function, but required for linear population function.",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa mapping lineages to species",
            "required": true
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "SpeciesTreePrior",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.SpeciesTreePrior",
        "description": "Species tree prior for *BEAST analysis",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "gammaParameter",
            "type": "RealParameter",
            "description": "scale parameter of the gamma distribution over population sizes. This makes this parameter half the expected population size on all branches for constant population function, but a quarter of the expected population size for tip branches only for linear population functions.",
            "required": true
          },
          {
            "name": "popFunction",
            "type": "SpeciesTreePopFunction.TreePopSizeFunction",
            "description": "Population function. This can be [constant, linear, linear_with_constant_root] (default 'constant')",
            "required": false,
            "default": "constant"
          },
          {
            "name": "bottomPopSize",
            "type": "RealParameter",
            "description": "population size parameter for populations at the bottom of a branch. For constant population function, this is the same at the top of the branch.",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "topPopSize",
            "type": "RealParameter",
            "description": "population size parameter at the top of a branch. Ignored for constant population function, but required for linear population function.",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa mapping lineages to species",
            "required": true
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "StarBeastStartState",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.StarBeastStartState",
        "description": "Set a starting point for a *BEAST analysis from gene alignment data.",
        "generatorType": "function",
        "generatedType": "StarBeastStartState",
        "arguments": [
          {
            "name": "method",
            "type": "StarBeastStartState.Method",
            "description": "Initialise either with a totally random state or a point estimate based on alignments data (default point-estimate)",
            "required": false,
            "default": "point-estimate"
          },
          {
            "name": "speciesTree",
            "type": "Tree",
            "description": "The species tree to initialize",
            "required": false
          },
          {
            "name": "gene",
            "type": "List<Tree>",
            "description": "Gene trees to initialize",
            "required": false,
            "default": "[]"
          },
          {
            "name": "calibratedYule",
            "type": "CalibratedYuleModel",
            "description": "The species tree (with calibrations) to initialize",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "popMean",
            "type": "RealParameter",
            "description": "Population mean hyper prior to initialse",
            "required": false
          },
          {
            "name": "birthRate",
            "type": "RealParameter",
            "description": "Tree prior birth rate to initialize",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "speciesTreePrior",
            "type": "SpeciesTreePrior",
            "description": "Population size parameters to initialise",
            "required": false
          },
          {
            "name": "baseRate",
            "type": "Function",
            "description": "Main clock rate used to scale trees (default 1).",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "TreeTopFinder",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.TreeTopFinder",
        "description": "Finds height of highest tree among a set of trees",
        "generatorType": "function",
        "generatedType": "TreeTopFinder",
        "arguments": [
          {
            "name": "tree",
            "type": "List<Tree>",
            "description": "set of trees to search among",
            "required": false,
            "default": "[]"
          }
        ]
      },
      {
        "name": "YuleModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.speciation.YuleModel",
        "description": "Pure birth model (i.e. no deaths)",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "birthDiffRate",
            "type": "RealParameter",
            "description": "birth difference rate parameter, lambda - mu in birth\/death model (diversification rate)",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "originHeight",
            "type": "RealParameter",
            "description": "the height of the point of origin of the process",
            "required": false
          },
          {
            "name": "conditionalOnRoot",
            "type": "Boolean",
            "description": "Whether to condition on the root (default false)",
            "required": false,
            "default": "false"
          },
          {
            "name": "treeIntervals",
            "type": "TreeIntervals",
            "description": "Intervals for a phylogenetic beast tree",
            "required": false
          }
        ]
      },
      {
        "name": "BinaryCovarion",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.BinaryCovarion",
        "description": "Covarion model for Binary data",
        "generatorType": "function",
        "generatedType": "BinaryCovarion",
        "arguments": [
          {
            "name": "alpha",
            "type": "RealParameter",
            "description": "the rate of evolution in slow mode",
            "required": true
          },
          {
            "name": "switchRate",
            "type": "RealParameter",
            "description": "the rate of flipping between slow and fast modes",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "vfrequencies",
            "type": "RealParameter",
            "description": "the frequencies of the visible states",
            "required": true
          },
          {
            "name": "hfrequencies",
            "type": "RealParameter",
            "description": "the frequencies of the hidden rates",
            "required": false
          },
          {
            "name": "mode",
            "type": "BinaryCovarion.MODE",
            "description": "one of BEAST, REVERSIBLE, TUFFLESTEEL BEAST = implementation as in BEAST 1 REVERSIBLE = like BEAST 1 implementation, but using frequencies to make it reversible TUFFLEYSTEEL = Tuffley & Steel (1996) impementation (no rates for ",
            "required": false,
            "default": "BEAST"
          },
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "Blosum62",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.Blosum62",
        "description": "BLOSUM62 model of amino acid evolution Henikoff, S., and J. G. Henikoff. 1992. PNAS USA 89:10915-10919.",
        "generatorType": "function",
        "generatedType": "Blosum62",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "ComplexSubstitutionModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.ComplexSubstitutionModel",
        "description": "Complex-diagonalizable, irreversible substitution model",
        "generatorType": "function",
        "generatedType": "ComplexSubstitutionModel",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "CPREV",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.CPREV",
        "description": " CPREV 45 model of amino acid evolution  Adachi, J., P.J. Waddell, W. Martin, and M. Hasegawa. 2000. JME 50:348-358",
        "generatorType": "function",
        "generatedType": "CPREV",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "Dayhoff",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.Dayhoff",
        "description": " Dayhoff model for amino acid evolution  Dayhoff, M.O., Schwartz, R.M., Orcutt, B.C. (1978)  A model of evolutionary change in proteins.  Dayhoff, M.O. (ed.) Atlas of Protein Sequence Structur., Vol5, Suppl. 3,  National Biomedical Research Foundation, Washington DC, pp. 345-352.",
        "generatorType": "function",
        "generatedType": "Dayhoff",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "Frequencies",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.Frequencies",
        "description": "Represents character frequencies typically used as distribution of the root of the tree. Calculates empirical frequencies of characters in sequence data, or simply assumes a uniform distribution if the estimate flag is set to false.",
        "generatorType": "function",
        "generatedType": "Frequencies",
        "arguments": [
          {
            "name": "data",
            "type": "Alignment",
            "description": "Sequence data for which frequencies are calculated",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "Whether to estimate the frequencies from data (true=default) or assume a uniform distribution over characters (false)",
            "required": false,
            "default": "true"
          },
          {
            "name": "frequencies",
            "type": "RealParameter",
            "description": "A set of frequencies specified as space separated values summing to 1",
            "required": false,
            "recommended": true,
            "dimension": {
              "type": "contextual",
              "resolution": [
                {
                  "context": "parent",
                  "path": "stateCount",
                  "when": "parent implements SubstitutionModel"
                },
                {
                  "context": "sibling",
                  "path": "siteModel.substModel.stateCount",
                  "when": "parent is TreeLikelihood"
                },
                {
                  "context": "alignment",
                  "path": "dataType.stateCount",
                  "when": "alignment is available"
                }
              ]
            },
            "constraint": "simplex"
          }
        ]
      },
      {
        "name": "GeneralSubstitutionModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.GeneralSubstitutionModel",
        "description": "Specifies transition probability matrix with no restrictions on the rates other than that one of the is equal to one and the others are specified relative to this unit rate. Works for any number of states.",
        "generatorType": "function",
        "generatedType": "GeneralSubstitutionModel",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": true,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "GTR",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.GTR",
        "description": "General Time Reversible model of nucleotide evolution. Rates that are not specified are assumed to be 1. ",
        "generatorType": "function",
        "generatedType": "GTR",
        "arguments": [
          {
            "name": "rateAC",
            "type": "Function",
            "description": "substitution rate for A to C (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateAG",
            "type": "Function",
            "description": "substitution rate for A to G (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateAT",
            "type": "Function",
            "description": "substitution rate for A to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateCG",
            "type": "Function",
            "description": "substitution rate for C to G (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateCT",
            "type": "Function",
            "description": "substitution rate for C to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateGT",
            "type": "Function",
            "description": "substitution rate for G to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "HKY",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.HKY",
        "description": "HKY85 (Hasegawa, Kishino & Yano, 1985) substitution model of nucleotide evolution.",
        "generatorType": "function",
        "generatedType": "HKY",
        "arguments": [
          {
            "name": "kappa",
            "type": "Function",
            "description": "kappa parameter in HKY model",
            "required": true
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "JTT",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.JTT",
        "description": " * JTT model for amino acid evolution  D.T. Jones, W.R. Taylor, and J.M. Thornton  The rapid generation of mutation data matrices from protein sequences  CABIOS  vol. 8 no. 3 1992 pp. 275-282.",
        "generatorType": "function",
        "generatedType": "JTT",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "JukesCantor",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.JukesCantor",
        "description": "Jukes Cantor substitution model: all rates equal and uniformly distributed frequencies",
        "generatorType": "function",
        "generatedType": "JukesCantor",
        "arguments": [
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "MTREV",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.MTREV",
        "description": "MTREV24 model of amino acid evolution  (complete sequence data of mtDNA from 24 vertebrate species)  Adachi, J., and Hasegawa, M. 1996. J. Mol. Evol. 42:459-468.",
        "generatorType": "function",
        "generatedType": "MTREV",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "MutationDeathModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.MutationDeathModel",
        "description": "Mutation Death substitution model, can be used as Stochastic Dollo model.",
        "generatorType": "function",
        "generatedType": "MutationDeathModel",
        "arguments": [
          {
            "name": "deathprob",
            "type": "RealParameter",
            "description": "rate of death, used to calculate death probability",
            "required": true,
            "constraint": "probability"
          },
          {
            "name": "substmodel",
            "type": "SubstitutionModel.Base",
            "description": "CTMC Model for the life states, so should have a state-space one less than this model. If not specified, ...",
            "required": false
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "SYM",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.SYM",
        "description": "Symmetrical model of nucleotide evolution with equal base frequencies.Rates that are not specified are assumed to be 1.",
        "generatorType": "function",
        "generatedType": "SYM",
        "arguments": [
          {
            "name": "rateAC",
            "type": "RealParameter",
            "description": "substitution rate for A to C (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateAG",
            "type": "RealParameter",
            "description": "substitution rate for A to G (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateAT",
            "type": "RealParameter",
            "description": "substitution rate for A to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateCG",
            "type": "RealParameter",
            "description": "substitution rate for C to G (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateCT",
            "type": "RealParameter",
            "description": "substitution rate for C to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateGT",
            "type": "RealParameter",
            "description": "substitution rate for G to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "TIM",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.TIM",
        "description": "Transition model of nucleotide evolution (variable transition rates, two transversion rates). Rates that are not specified are assumed to be 1.",
        "generatorType": "function",
        "generatedType": "TIM",
        "arguments": [
          {
            "name": "rateAG",
            "type": "RealParameter",
            "description": "substitution rate for A to G (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateCT",
            "type": "RealParameter",
            "description": "substitution rate for C to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateTransversions1",
            "type": "RealParameter",
            "description": "substitution rate for A<->C and G<->T",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateTransversions2",
            "type": "RealParameter",
            "description": "substitution rate for C<->G and A<->T",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "TN93",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.TN93",
        "description": "TN93 (Tamura and Nei, 1993) substitution model of nucleotide evolution.",
        "generatorType": "function",
        "generatedType": "TN93",
        "arguments": [
          {
            "name": "kappa1",
            "type": "RealParameter",
            "description": "rate of A<->G transitions",
            "required": true
          },
          {
            "name": "kappa2",
            "type": "RealParameter",
            "description": "rate of C<->T transitions",
            "required": true
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "TVM",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.TVM",
        "description": "Transversion model of nucleotide evolution (variable transversion rates, equal transition rates).Rates that are not specified are assumed to be 1.",
        "generatorType": "function",
        "generatedType": "TVM",
        "arguments": [
          {
            "name": "rateAC",
            "type": "RealParameter",
            "description": "substitution rate for A to C (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateAT",
            "type": "RealParameter",
            "description": "substitution rate for A to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateCG",
            "type": "RealParameter",
            "description": "substitution rate for C to G (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateGT",
            "type": "RealParameter",
            "description": "substitution rate for G to T (default 1)",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rateTransitions",
            "type": "RealParameter",
            "description": "substitution rate for A<->G and C<->T",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": true
          }
        ]
      },
      {
        "name": "WAG",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.substitutionmodel.WAG",
        "description": "WAG model of amino acid evolution by S. Whelan and N. Goldman. 2001. Molecular biology and evolution 18.5 (2001): 691-699 ",
        "generatorType": "function",
        "generatedType": "WAG",
        "arguments": [
          {
            "name": "rates",
            "type": "Function",
            "description": "Rate parameter which defines the transition rate matrix. Only the off-diagonal entries need to be specified (diagonal makes row sum to zero in a rate matrix). Entry i specifies the rate from floor(i\/(n-1)) to i%(n-1)+delta where n is the number of states and delta=1 if floor(i\/(n-1)) <= i%(n-1) and 0 otherwise.",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "eigenSystem",
            "type": "String",
            "description": "Name of the class used for creating an EigenSystem",
            "required": false,
            "default": "beast.base.evolution.substitutionmodel.DefaultEigenSystem"
          },
          {
            "name": "frequencies",
            "type": "Frequencies",
            "description": "substitution model equilibrium state frequencies",
            "required": false
          }
        ]
      },
      {
        "name": "Sum",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.Sum",
        "description": "calculates sum of a valuable",
        "generatorType": "function",
        "generatedType": "Sum",
        "arguments": [
          {
            "name": "arg",
            "type": "List<Function>",
            "description": "argument to be summed",
            "required": true,
            "default": "[]"
          },
          {
            "name": "tree",
            "type": "Tree",
            "description": "the tree corresponding to the function to be summed, indexing by node numbers assumed.",
            "required": false
          },
          {
            "name": "ignoreZeroBranchLengths",
            "type": "Boolean",
            "description": "true if quantities in the argument should only be summed for non-zero branch lengths.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "ClusterTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.ClusterTree",
        "description": "Create initial beast.tree by hierarchical clustering, either through one of the classic link methods or by neighbor joining. The following link methods are supported: <br\/>o single link, <br\/>o complete link, <br\/>o UPGMA=average link, <br\/>o mean link, <br\/>o centroid, <br\/>o Ward and <br\/>o adjusted complete link <br\/>o neighborjoining <br\/>o neighborjoining2 - corrects tree for tip data, unlike plain neighborjoining",
        "generatorType": "function",
        "generatedType": "ClusterTree",
        "arguments": [
          {
            "name": "clusterType",
            "type": "ClusterTree.Type",
            "description": "type of clustering algorithm used for generating initial beast.tree. Should be one of [single, average, complete, upgma, mean, centroid, ward, adjcomplete, neighborjoining, neighborjoining2] (default average)",
            "required": false,
            "default": "average"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "alignment data used for calculating distances for clustering",
            "required": false
          },
          {
            "name": "distance",
            "type": "Distance",
            "description": "method for calculating distance between two sequences (default Jukes Cantor)",
            "required": false
          },
          {
            "name": "clock.rate",
            "type": "Function",
            "description": "the clock rate parameter, used to divide all divergence times by, to convert from substitutions to times. (default 1.0)",
            "required": false,
            "default": "constant",
            "constraint": "positive"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "BayesianSkyline",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.BayesianSkyline",
        "description": "Bayesian skyline: A likelihood function for the generalized skyline plot coalescent.",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "popSizes",
            "type": "Function",
            "description": "present-day population size. If time units are set to Units.EXPECTED_SUBSTITUTIONS thenthe N0 parameter will be interpreted as N0 * mu. Also note that if you are dealing with a diploid population N0 will be out by a factor of 2.",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "groupSizes",
            "type": "IntegerParameter",
            "description": "the group sizes parameter",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "tree over which to calculate a prior or likelihood",
            "required": false
          }
        ]
      },
      {
        "name": "Coalescent",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.Coalescent",
        "description": "Calculates the probability of a beast.tree conditional on a population size function. Note that this does not take the number of possible tree interval\/tree topology combinations in account, in other words, the constant required for making this a proper distribution that integrates to unity is not calculated (partly, because we don't know how for sequentially sampled data).",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "populationModel",
            "type": "PopulationFunction",
            "description": "A population size model",
            "required": true
          },
          {
            "name": "tree",
            "type": "TreeInterface",
            "description": "tree over which to calculate a prior or likelihood",
            "required": false
          }
        ]
      },
      {
        "name": "CompoundPopulationFunction",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.CompoundPopulationFunction",
        "description": "An effective population size function based on coalecent times from a set of trees.",
        "generatorType": "function",
        "generatedType": "CompoundPopulationFunction",
        "arguments": [
          {
            "name": "populationSizes",
            "type": "RealParameter",
            "description": "population value at each point.",
            "required": true,
            "constraint": "positive-integer"
          },
          {
            "name": "populationIndicators",
            "type": "BooleanParameter",
            "description": "Include\/exclude population value from the population function.",
            "required": true
          },
          {
            "name": "itree",
            "type": "List<TreeIntervals>",
            "description": "Coalecent intervals of this tree are used in the compound population function.",
            "required": true,
            "default": "[]"
          },
          {
            "name": "type",
            "type": "String",
            "description": "Flavour of demographic: either linear or stepwise for  piecewise-linear or piecewise-constant.",
            "required": false,
            "default": "linear"
          },
          {
            "name": "useIntervalsMiddle",
            "type": "Boolean",
            "description": "When true, the demographic X axis points are in the middle of the coalescent intervals. By default they are at the beginning.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "ConstantPopulation",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.ConstantPopulation",
        "description": "coalescent intervals for a constant population",
        "generatorType": "function",
        "generatedType": "ConstantPopulation",
        "arguments": [
          {
            "name": "popSize",
            "type": "Function",
            "description": "constant (effective) population size value.",
            "required": true,
            "constraint": "positive-integer"
          }
        ]
      },
      {
        "name": "ExponentialGrowth",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.ExponentialGrowth",
        "description": "Coalescent intervals for a exponentially growing population.",
        "generatorType": "function",
        "generatedType": "ExponentialGrowth",
        "arguments": [
          {
            "name": "popSize",
            "type": "Function",
            "description": "present-day population size (defaults to 1.0). ",
            "required": false,
            "constraint": "positive-integer"
          },
          {
            "name": "growthRate",
            "type": "Function",
            "description": "Growth rate is the exponent of the exponential growth. A value of zero represents a constant population size, negative values represent decline towards the present, positive numbers represents exponential growth towards the present.",
            "required": false,
            "constraint": "positive"
          }
        ]
      },
      {
        "name": "RandomTree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.RandomTree",
        "description": "This class provides the basic engine for coalescent simulation of a given demographic model over a given time period. ",
        "generatorType": "function",
        "generatedType": "RandomTree",
        "arguments": [
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "set of taxa to initialise tree specified by alignment",
            "required": false
          },
          {
            "name": "populationModel",
            "type": "PopulationFunction",
            "description": "population function for generating coalescent???",
            "required": true
          },
          {
            "name": "constraint",
            "type": "List<MRCAPrior>",
            "description": "specifies (monophyletic or height distribution) constraints on internal nodes",
            "required": false,
            "default": "[]"
          },
          {
            "name": "rootHeight",
            "type": "Double",
            "description": "If specified the tree will be scaled to match the root height, if constraints allow this",
            "required": false
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "ScaledPopulationFunction",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.coalescent.ScaledPopulationFunction",
        "description": "Scale a demographic function by a constant factor",
        "generatorType": "function",
        "generatedType": "ScaledPopulationFunction",
        "arguments": [
          {
            "name": "population",
            "type": "PopulationFunction",
            "description": "population function to scale. ",
            "required": true
          },
          {
            "name": "factor",
            "type": "Function",
            "description": "scale population by this facor.",
            "required": true
          }
        ]
      },
      {
        "name": "MRCAPrior",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.MRCAPrior",
        "description": "Prior over set of taxa, useful for defining monophyletic constraints and distributions over MRCA times or (sets of) tips of trees. Be aware that the distribution is in units equal to that used in the tree: if the tree has intenal node heights representing age, the distribution represents age, if the tree is in units of a date since some time in the past (e.g. if tip dates are added) the distribution is in units of date since some time in the past.",
        "generatorType": "distribution",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa for which prior information is available",
            "required": false
          },
          {
            "name": "monophyletic",
            "type": "Boolean",
            "description": "whether the taxon set is monophyletic (forms a clade without other taxa) or nor. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior over MRCA time, e.g. normal, beta, gamma. If not specified, monophyletic must be true",
            "required": false
          },
          {
            "name": "tipsonly",
            "type": "Boolean",
            "description": "flag to indicate tip dates are to be used instead of the MRCA node. If set to true, the prior is applied to the height of all tips in the taxonset and the monophyletic flag is ignored. Default is false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "useOriginate",
            "type": "Boolean",
            "description": "Use parent of clade instead of clade. Cannot be used with tipsonly, or on the root.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "Node",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.Node",
        "description": "Nodes in building beast.tree data structure.",
        "generatorType": "function",
        "generatedType": "Node",
        "arguments": []
      },
      {
        "name": "TraitSet",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.TraitSet",
        "description": "A trait set represent a collection of properties of taxons, for the use of initializing a tree. The traits are represented as text content in taxon=value form, for example, for a date trait, wecould have a content of chimp=1950,human=1991,neander=-10000. All white space is ignored, so they canbe put on multiple tabbed lines in the XML. The type of node in the tree determines what happes with this information. The default Node only recognizes 'date', 'date-forward' and 'date-backward' as a trait, but by creating custom Node classes other traits can be supported as well.",
        "generatorType": "function",
        "generatedType": "TraitSet",
        "arguments": [
          {
            "name": "traitname",
            "type": "String",
            "description": "name of the trait, used as meta data name for the tree. Special traitnames that are recognized are 'age','date','date-forward' and 'date-backward'.",
            "required": true
          },
          {
            "name": "units",
            "type": "TraitSet.Units",
            "description": "name of the units in which values are posed, used for conversion to a real value. This can be [year, month, day] (default 'year')",
            "required": false,
            "default": "year"
          },
          {
            "name": "value",
            "type": "String",
            "description": "traits encoded as taxon=value pairs separated by commas",
            "required": true
          },
          {
            "name": "taxa",
            "type": "TaxonSet",
            "description": "contains list of taxa to map traits to",
            "required": true
          },
          {
            "name": "dateFormat",
            "type": "String",
            "description": "the date\/time format to be parsed, (e.g., 'dd\/M\/yyyy')",
            "required": false
          }
        ]
      },
      {
        "name": "Tree",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.Tree",
        "description": "Tree (the T in BEAST) representing gene beast.tree, species beast.tree, language history, or other time-beast.tree relationships among sequence data.",
        "generatorType": "function",
        "generatedType": "Tree",
        "arguments": [
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "TreeIntervals",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeIntervals",
        "description": "Extracts the intervals from a tree. Points in the intervals are defined by the heights of nodes in the tree.",
        "generatorType": "function",
        "generatedType": "TreeIntervals",
        "arguments": [
          {
            "name": "tree",
            "type": "Tree",
            "description": "tree for which to calculate the intervals",
            "required": true
          }
        ]
      },
      {
        "name": "TreeParser",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.evolution.tree.TreeParser",
        "description": "Create beast.tree by parsing from a specification of a beast.tree in Newick format (includes parsing of any meta data in the Newick string).",
        "generatorType": "function",
        "generatedType": "TreeParser",
        "arguments": [
          {
            "name": "IsLabelledNewick",
            "type": "Boolean",
            "description": "Is the newick tree labelled (alternatively contains node numbers)? Default=false.",
            "required": false,
            "default": "false"
          },
          {
            "name": "taxa",
            "type": "Alignment",
            "description": "Specifies the list of taxa represented by leaves in the beast.tree",
            "required": false
          },
          {
            "name": "newick",
            "type": "String",
            "description": "initial beast.tree represented in newick format",
            "required": false
          },
          {
            "name": "offset",
            "type": "Integer",
            "description": "offset if numbers are used for taxa (offset=the lowest taxa number) default=1",
            "required": false,
            "default": "1"
          },
          {
            "name": "threshold",
            "type": "Double",
            "description": "threshold under which node heights (derived from lengths) are set to zero. Default=0.",
            "required": false,
            "default": "0.0"
          },
          {
            "name": "singlechild",
            "type": "Boolean",
            "description": "flag to indicate that single child nodes are allowed. Default=true.",
            "required": false,
            "default": "true"
          },
          {
            "name": "adjustTipHeights",
            "type": "Boolean",
            "description": "flag to indicate if tipHeights shall be adjusted when date traits missing. Default=true.",
            "required": false,
            "default": "true"
          },
          {
            "name": "scale",
            "type": "Double",
            "description": "scale used to multiply internal node heights during parsing. Useful for importing starting from external programs, for instance, RaxML tree rooted using Path-o-gen.",
            "required": false,
            "default": "1.0",
            "constraint": "positive"
          },
          {
            "name": "binarizeMultifurcations",
            "type": "Boolean",
            "description": "Whether or not to turn multifurcations into sequences of bifurcations. (Default true.)",
            "required": false,
            "default": "true"
          },
          {
            "name": "initial",
            "type": "Tree",
            "description": "tree to start with",
            "required": false
          },
          {
            "name": "trait",
            "type": "List<TraitSet>",
            "description": "trait information for initializing traits (like node dates) in the tree",
            "required": false,
            "default": "[]"
          },
          {
            "name": "taxonset",
            "type": "TaxonSet",
            "description": "set of taxa that correspond to the leafs in the tree",
            "required": false
          },
          {
            "name": "nodetype",
            "type": "String",
            "description": "type of the nodes in the beast.tree",
            "required": false,
            "default": "beast.base.evolution.tree.Node"
          },
          {
            "name": "adjustTreeNodeHeights",
            "type": "Boolean",
            "description": "if true (default), then tree node heights are adjusted to avoid non-positive branch lengths. If you want to maintain zero branch lengths then you must set this to false.",
            "required": false,
            "default": "true"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "CompoundDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.CompoundDistribution",
        "description": "Takes a collection of distributions, typically a number of likelihoods and priors and combines them into the compound of these distributions typically interpreted as the posterior.",
        "generatorType": "distribution",
        "arguments": [
          {
            "name": "distribution",
            "type": "List<Distribution>",
            "description": "individual probability distributions, e.g. the likelihood and prior making up a posterior",
            "required": false,
            "default": "[]"
          },
          {
            "name": "useThreads",
            "type": "Boolean",
            "description": "calculated the distributions in parallel using threads (default false)",
            "required": false,
            "default": "false"
          },
          {
            "name": "threads",
            "type": "Integer",
            "description": "maximum number of threads to use, if less than 1 the number of threads in BeastMCMC is used (default -1)",
            "required": false,
            "default": "-1"
          },
          {
            "name": "ignore",
            "type": "Boolean",
            "description": "ignore all distributions and return 1 as distribution (default false)",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "Beta",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Beta",
        "description": "Beta distribution, used as prior.  p(x;alpha,beta) = \frac{x^{alpha-1}(1-x)^{beta-1}} {B(alpha,beta)} where B() is the beta function. If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "Function",
            "description": "first shape parameter, defaults to 1",
            "required": false,
            "recommended": true
          },
          {
            "name": "beta",
            "type": "Function",
            "description": "the other shape parameter, defaults to 1",
            "required": false,
            "recommended": true
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "ChiSquare",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.ChiSquare",
        "description": "Chi square distribution, f(x; k) = \\frac{1}{2^{k\/2}Gamma(k\/2)} x^{k\/2-1} e^{-x\/2} If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "df",
            "type": "IntegerParameter",
            "description": "degrees if freedin, defaults to 1",
            "required": false
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "Dirichlet",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Dirichlet",
        "description": "Dirichlet distribution.  p(x_1,...,x_n;alpha_1,...,alpha_n) = 1\/B(alpha) prod_{i=1}^K x_i^{alpha_i - 1} where B() is the beta function B(alpha) = prod_{i=1}^K Gamma(alpha_i)\/ Gamma(sum_{i=1}^K alpha_i}. ",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "Function",
            "description": "coefficients of the Dirichlet distribution",
            "required": true
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "Exponential",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Exponential",
        "description": "Exponential distribution.  f(x;\\lambda) = 1\/\\lambda e^{-x\/\\lambda}, if x >= 0 If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "mean",
            "type": "Function",
            "description": "mean parameter, defaults to 1",
            "required": false,
            "recommended": true
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "Gamma",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Gamma",
        "description": "Gamma distribution. for x>0  g(x;alpha,beta) = 1\/Gamma(alpha) beta^alpha} x^{alpha - 1} e^{-\frac{x}{beta}}If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "Function",
            "description": "shape parameter, defaults to 2",
            "required": false,
            "recommended": true
          },
          {
            "name": "beta",
            "type": "Function",
            "description": "second parameter depends on mode, defaults to 2.For mode=ShapeScale beta is interpreted as scale. For mode=ShapeRate beta is interpreted as rate. For mode=ShapeMean beta is interpreted as mean.For mode=OneParameter beta is ignored.",
            "required": false,
            "recommended": true
          },
          {
            "name": "mode",
            "type": "Gamma.mode",
            "description": "determines parameterisation. For ShapeScale beta is interpreted as scale. For ShapeRate beta is interpreted as rate. For ShapeMean beta is interpreted as mean.For OneParameter beta is ignored.",
            "required": false,
            "default": "ShapeScale"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "InverseGamma",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.InverseGamma",
        "description": "Inverse Gamma distribution, used as prior.    for x>0  f(x; alpha, beta) = \frac{beta^alpha}{Gamma(alpha)} (1\/x)^{alpha + 1}exp(-beta\/x) If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "alpha",
            "type": "Function",
            "description": "shape parameter, defaults to 2",
            "required": false
          },
          {
            "name": "beta",
            "type": "Function",
            "description": "scale parameter, defaults to 2",
            "required": false
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "LaplaceDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.LaplaceDistribution",
        "description": "Laplace distribution.    f(x|\\mu,b) = \\frac{1}{2b} \\exp \\left( -\\frac{|x-\\mu|}{b} \\right)The probability density function of the Laplace distribution is also reminiscent of the normal distribution; however, whereas the normal distribution is expressed in terms of the squared difference from the mean ?, the Laplace density is expressed in terms of the absolute difference from the mean. Consequently the Laplace distribution has fatter tails than the normal distribution.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "mu",
            "type": "Function",
            "description": "location parameter, defaults to 0",
            "required": false
          },
          {
            "name": "scale",
            "type": "Function",
            "description": "scale parameter, defaults to 1",
            "required": false,
            "constraint": "positive"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "LogNormalDistributionModel",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.LogNormalDistributionModel",
        "description": "A log-normal distribution with mean and variance parameters.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "M",
            "type": "Function",
            "description": "M parameter of lognormal distribution. Equal to the mean of the log-transformed distribution.",
            "required": false,
            "recommended": true
          },
          {
            "name": "S",
            "type": "Function",
            "description": "S parameter of lognormal distribution. Equal to the standard deviation of the log-transformed distribution.",
            "required": false,
            "recommended": true
          },
          {
            "name": "meanInRealSpace",
            "type": "Boolean",
            "description": "Whether the M parameter is in real space, or in log-transformed space. Default false = log-transformed.",
            "required": false,
            "default": "false"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "MarkovChainDistribution",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.MarkovChainDistribution",
        "description": "A class that produces a distribution chaining values in a parameter through the Gamma distribution. The value of a parameter is assumed to be Gamma distributed with mean as the previous value in the parameter. If useLogNormal is set, a log normal distribution is used instead of a Gamma. If a Jeffrey's prior is used, the first value is assumed to be distributed as 1\/x, otherwise it is assumed to be uniform. Handy for population parameters. ",
        "generatorType": "distribution",
        "generatedType": "Function",
        "arguments": [
          {
            "name": "jeffreys",
            "type": "Boolean",
            "description": "use Jeffrey's prior (default false)",
            "required": false,
            "default": "false"
          },
          {
            "name": "reverse",
            "type": "Boolean",
            "description": "parameter in reverse (default false)",
            "required": false,
            "default": "false"
          },
          {
            "name": "uselog",
            "type": "Boolean",
            "description": "use logarithm of parameter values (default false)",
            "required": false,
            "default": "false"
          },
          {
            "name": "shape",
            "type": "Double",
            "description": "shape parameter of the Gamma distribution (default 1.0 = exponential distribution)  or precision parameter if the log normal is used.",
            "required": false,
            "default": "1.0"
          },
          {
            "name": "initialMean",
            "type": "Function",
            "description": "the mean of the prior distribution on the first element. This is an alternative boundary condition to Jeffrey's on the first value.",
            "required": false
          },
          {
            "name": "useLogNormal",
            "type": "Boolean",
            "description": "use Log Normal distribution instead of Gamma (default false)",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "Normal",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Normal",
        "description": "Normal distribution.  f(x) = frac{1}{\\sqrt{2\\pi\\sigma^2}} e^{ -\\frac{(x-\\mu)^2}{2\\sigma^2} } If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "mean",
            "type": "Function",
            "description": "mean of the normal distribution, defaults to 0",
            "required": false,
            "recommended": true
          },
          {
            "name": "sigma",
            "type": "Function",
            "description": "standard deviation of the normal distribution, defaults to 1",
            "required": false,
            "recommended": true
          },
          {
            "name": "tau",
            "type": "Function",
            "description": "precision of the normal distribution, defaults to 1",
            "required": false
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "OneOnX",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.OneOnX",
        "description": "OneOnX distribution.  f(x) = C\/x for some normalizing constant C. If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "Poisson",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Poisson",
        "description": "Poisson distribution, used as prior  f(k; lambda)=\\frac{lambda^k e^{-lambda}}{k!}  If the input x is a multidimensional parameter, each of the dimensions is considered as a separate independent component.",
        "generatorType": "distribution",
        "generatedType": "IntegerParameter",
        "arguments": [
          {
            "name": "lambda",
            "type": "Function",
            "description": "rate parameter, defaults to 1",
            "required": false
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "Prior",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Prior",
        "description": "Produces prior (log) probability of value x.If x is multidimensional, the components of x are assumed to be independent, so the sum of log probabilities of all elements of x is returned as the prior.",
        "generatorType": "distribution",
        "generatedType": "Function",
        "arguments": [
          {
            "name": "distr",
            "type": "ParametricDistribution",
            "description": "distribution used to calculate prior, e.g. normal, beta, gamma.",
            "required": true
          }
        ]
      },
      {
        "name": "Uniform",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.distribution.Uniform",
        "description": "Uniform distribution over a given interval (including lower and upper values)",
        "generatorType": "distribution",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "lower",
            "type": "Double",
            "description": "lower bound on the interval, default 0",
            "required": false,
            "recommended": true,
            "default": "0.0"
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "lower bound on the interval, default 1",
            "required": false,
            "recommended": true,
            "default": "1.0"
          },
          {
            "name": "offset",
            "type": "Double",
            "description": "offset of origin (defaults to 0)",
            "required": false,
            "default": "0.0"
          }
        ]
      },
      {
        "name": "BooleanParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.BooleanParameter",
        "description": "A Boolean-valued parameter represents a value (or array of values if the dimension is larger than one) in the state space that can be changed by operators.",
        "generatorType": "function",
        "generatedType": "BooleanParameter",
        "arguments": [
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": true,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "BooleanParameterList",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.BooleanParameterList",
        "description": "State node describing a list of boolean parameters.",
        "generatorType": "function",
        "generatedType": "BooleanParameterList",
        "arguments": [
          {
            "name": "initialParam",
            "type": "List<Parameter.Base>",
            "description": "Parameter whose value will initially be in parameter list.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "Dimension of individual parameters in list.  Default 1.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "Minor dimension of individual parameters in list. Default 1.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "CompoundRealParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.CompoundRealParameter",
        "description": "Parmeter consisting of 2 or more RealParameters but behaving like a single RealParameter",
        "generatorType": "function",
        "generatedType": "CompoundRealParameter",
        "arguments": [
          {
            "name": "parameter",
            "type": "List<RealParameter>",
            "description": "parameters making up the compound parameter",
            "required": true,
            "default": "[]"
          },
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "CompoundValuable",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.CompoundValuable",
        "description": "Summarizes a set of valuables so that for example a rate matrix can be specified that uses a parameter in various places in the matrix.",
        "generatorType": "function",
        "generatedType": "CompoundValuable",
        "arguments": [
          {
            "name": "var",
            "type": "List<BEASTObject>",
            "description": "reference to a valuable",
            "required": true,
            "default": "[]"
          }
        ]
      },
      {
        "name": "IntegerParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.IntegerParameter",
        "description": "An integer-valued parameter represents a value (or array of values if the dimension is larger than one) in the state space that can be changed by operators.",
        "generatorType": "function",
        "generatedType": "IntegerParameter",
        "arguments": [
          {
            "name": "lower",
            "type": "Integer",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Integer",
            "description": "upper value for this parameter  (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": true,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "IntegerParameterList",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.IntegerParameterList",
        "description": "State node describing a list of integer-valued parameters.",
        "generatorType": "function",
        "generatedType": "IntegerParameterList",
        "arguments": [
          {
            "name": "lower",
            "type": "Integer",
            "description": "Lower bound on parameter values.",
            "required": false,
            "default": "-2147483647"
          },
          {
            "name": "upper",
            "type": "Integer",
            "description": "Upper bound on parameter values.",
            "required": false,
            "default": "2147483646"
          },
          {
            "name": "initialParam",
            "type": "List<Parameter.Base>",
            "description": "Parameter whose value will initially be in parameter list.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "Dimension of individual parameters in list.  Default 1.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "Minor dimension of individual parameters in list. Default 1.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "RealParameter",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.RealParameter",
        "description": "A real-valued parameter represents a value (or array of values if the dimension is larger than one) in the state space that can be changed by operators.",
        "generatorType": "function",
        "generatedType": "RealParameter",
        "arguments": [
          {
            "name": "lower",
            "type": "Double",
            "description": "lower value for this parameter (default -infinity)",
            "required": false
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "upper value for this parameter (default +infinity)",
            "required": false
          },
          {
            "name": "value",
            "type": "List<T>",
            "description": "start value(s) for this parameter. If multiple values are specified, they should be separated by whitespace.",
            "required": true,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "dimension of the parameter (default 1, i.e scalar)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "minor-dimension when the parameter is interpreted as a matrix (default 1)",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "keys",
            "type": "String",
            "description": "the keys (unique dimension names) for the dimensions of this parameter",
            "required": false
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "RealParameterList",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.parameter.RealParameterList",
        "description": "State node describing a list of real-valued parameters.",
        "generatorType": "function",
        "generatedType": "RealParameterList",
        "arguments": [
          {
            "name": "lower",
            "type": "Double",
            "description": "Lower bound on parameter values.",
            "required": false,
            "default": "-Infinity"
          },
          {
            "name": "upper",
            "type": "Double",
            "description": "Upper bound on parameter values.",
            "required": false,
            "default": "Infinity"
          },
          {
            "name": "initialParam",
            "type": "List<Parameter.Base>",
            "description": "Parameter whose value will initially be in parameter list.",
            "required": false,
            "default": "[]"
          },
          {
            "name": "dimension",
            "type": "Integer",
            "description": "Dimension of individual parameters in list.  Default 1.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "minordimension",
            "type": "Integer",
            "description": "Minor dimension of individual parameters in list. Default 1.",
            "required": false,
            "default": "1",
            "constraint": "positive-integer"
          },
          {
            "name": "estimate",
            "type": "Boolean",
            "description": "whether to estimate this item or keep constant to its initial value",
            "required": false,
            "default": "true"
          }
        ]
      },
      {
        "name": "State",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.State",
        "description": "The state represents the current point in the state space, and maintains values of a set of StateNodes, such as parameters and trees. Furthermore, the state manages which parts of the model need to be stored\/restored and notified that recalculation is appropriate.",
        "generatorType": "function",
        "generatedType": "State",
        "arguments": [
          {
            "name": "stateNode",
            "type": "List<StateNode>",
            "description": "anything that is part of the state",
            "required": false,
            "default": "[]"
          },
          {
            "name": "storeEvery",
            "type": "Integer",
            "description": "store the state to disk every X number of samples so that we can resume computation later on if the process failed half-way.",
            "required": false,
            "default": "-1"
          },
          {
            "name": "experimental",
            "type": "Boolean",
            "description": "Use experimental code to calculate calcNodePath.",
            "required": false,
            "default": "false"
          }
        ]
      },
      {
        "name": "ESS",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.util.ESS",
        "description": "Report effective sample size of a parameter or log values from a distribution. This uses the same criterion as Tracer and assumes 10% burn in.",
        "generatorType": "function",
        "generatedType": "ESS",
        "arguments": [
          {
            "name": "arg",
            "type": "Function",
            "description": "value (e.g. parameter or distribution) to report ESS for",
            "required": true
          }
        ]
      },
      {
        "name": "RPNcalculator",
        "package": "BEAST.base",
        "fullyQualifiedName": "beast.base.inference.util.RPNcalculator",
        "description": "RPN calculator to evaluate simple expressions of parameters (Reverse Polish notation is a mathematical notation wherein every operator follows its operands)",
        "generatorType": "function",
        "generatedType": "RPNcalculator",
        "arguments": [
          {
            "name": "expression",
            "type": "String",
            "description": "Expressions needed for the calculations",
            "required": true
          },
          {
            "name": "parameter",
            "type": "List<Function>",
            "description": "Parameters needed for the calculations",
            "required": false,
            "default": "[]"
          },
          {
            "name": "argnames",
            "type": "String",
            "description": "names of arguments used in expression (comma delimited), order as given by XML",
            "required": false
          }
        ]
      },
      {
        "name": "FilteredTree",
        "package": "CCD",
        "fullyQualifiedName": "ccd.model.FilteredTree",
        "description": "BEAST2 FilteredTree",
        "generatorType": "function",
        "arguments": [],
        "generatedType": "FilteredTree"
      }
    ]
  }
}